<?xml version="1.0" standalone="yes"?>
<generator name="JavaScript">
	<code_localization />

	<!--
	****************************************************************************
	Escape sequences
	****************************************************************************
	-->

	<!-- Backslash must be double-quoted -->
	<escape-sequence for="\" do="\\" />
	<!-- Escape double quotation marks -->
	<escape-sequence for="&#x22;" do="\&#x22;" />

	<!--
	****************************************************************************
	Value-stack templates
	****************************************************************************
	-->

	<vstack_def_type>any</vstack_def_type>
	<vstack_term_type>any</vstack_term_type>
	<vstack_union_att>@@value-type-id</vstack_union_att>
	<vstack_union_def>@@attribute: null, </vstack_union_def>
	<vstack_single>value: null</vstack_single>
	<vstack_union_start>value: {</vstack_union_start>
	<vstack_union_end>}</vstack_union_end>

	<!--
	****************************************************************************
	Semantic action templates
	****************************************************************************
	-->

	<action_start>@@prefixParserControlBlock.prototype.parse_@@production-number = function() {
</action_start>
	<action_end>	;
}

</action_end>

	<action_single>pcb.stack[ pcb.stack.length - ( @@offset + 1 ) ].value</action_single>

	<action_union>pcb.stack[ pcb.stack.length - ( @@offset + 1 ) ].value.@@attribute</action_union>
	<action_lhs_single>pcb.ret</action_lhs_single>
	<action_lhs_union>pcb.ret.@@attribute</action_lhs_union>

	<action_set_lhs>pcb.lhs = @@sym</action_set_lhs>

	<!--
	****************************************************************************
	Semantic terminal action templates
	****************************************************************************
	-->

	<scan_action_start>@@prefixParserControlBlock.prototype.scan_@@production-number = function() {
</scan_action_start>
	<scan_action_end>	;
}

</scan_action_end>

	<scan_action_begin_offset>pcb.buf</scan_action_begin_offset>
	<scan_action_end_offset>pcb.len</scan_action_end_offset>
	<scan_action_ret_single>pcb.tos.value</scan_action_ret_single>
	<scan_action_ret_union>pcb.tos.value.@@attribute</scan_action_ret_union>

	<scan_action_set_symbol>( this.sym = @@sym )</scan_action_set_symbol>

	<!--
	****************************************************************************
	Parse table templates
	****************************************************************************
	-->

	<defprod>
		<col>@@production-number</col>
		<col_sep>, </col_sep>
	</defprod>

	<acttab>
		<row_start>				{ </row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@symbol: [ @@action,@@index ]</col>
		<col_sep>, </col_sep>
	</acttab>

	<gotab>
		<row_start>				{ </row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@symbol: [ @@action,@@index ]</col>
		<col_sep>, </col_sep>
	</gotab>

	<!--
	****************************************************************************
	Lexer
	****************************************************************************
	-->

	<dfa_select>
		<col>@@machine</col>
		<col_sep>, </col_sep>
	</dfa_select>

	<dfa_char>
		<col>@@from, @@to</col>
		<col_sep>, </col_sep>
	</dfa_char>

	<dfa_trans>
		<col>@@goto</col>
		<col_sep>, </col_sep>
	</dfa_trans>

	<dfa_idx>
		<row_start>				[ </row_start>
		<row_end> ]</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@index</col>
		<col_sep>, </col_sep>
	</dfa_idx>

	<dfa_accept>
		<row_start>				[ </row_start>
		<row_end> ]</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@accept</col>
		<col_sep>, </col_sep>
	</dfa_accept>

	<!--
	****************************************************************************
	Symbol and production information tables
	****************************************************************************
	-->

	<symbols>
		<col>		{ "symbol": "@@symbol-name", "emit": "@@emit", "is-terminal": @@type, "is-lexem": @@lexem, "is-whitespace": @@whitespace, "is-greedy": @@greedy }</col>
		<col_sep>,&#x0A;</col_sep>
	</symbols>

	<productions>
		<col>		{ "production": "@@production", "emit": "@@emit", "length": @@length, "left-hand-side": @@lhs }</col>
		<col_sep>,&#x0A;</col_sep>
	</productions>

	<!--
	****************************************************************************
	JavaScript program
	****************************************************************************
	-->

<file filename="@@basename.js">// Parser module generated by unicc from @@filename.
// DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
@@prologue

function @@prefixNode(emit, match, children) {
	this.emit = emit;
	this.match = match;
	this.children = children;
}

@@prefixNode.prototype.dump = function(level) {
	if( level === undefined )
		level = 0;

	if( this.emit !== undefined ) {
		var txt = this.emit;

		for( var i = 0; i &lt; level; i++ )
			txt = " " + txt;

		if( this.match &amp;&amp; this.match != this.emit )
			txt += " (" + this.match + ")";

		console.log(txt);

		level++;
	}

	if( this.children ) {
		for( child of this.children )
			if( Boolean( child ) )
				child.dump(level);
	}
}

function @@prefixParserToken() {
	this.state = 0;
	this.line = 0;
	this.column = 0;

	this.node = null;

	@@value-type-definition
}

function @@prefixParserControlBlock() {
	// Stack
	this.stack = [];
	this.tos = null;

	// Values
	this.ret = null;

	// State
	this.act = null;
	this.idx = null;
	this.lhs = null;

	// Lookahead
	this.sym = -1;
	this.old_sym = -1;
	this.len = 0;

	// Lexical analysis
	this.lexem = null;
	this.next = null;
	this.eof = null;
	this.is_eof = false;

	// Input buffering
	this.input = null;
	this.buf = "";

	// Error handling
	this.error_delay = 3;
	this.error_count = 0;

	this.line = 1;
	this.column = 1;

	// User-defined
	@@pcb
}

// Parsing actions

@@scan_actions
@@actions

// Parser

function @@prefixParser() {
	this.grammar = {
		"symbols": [
			@@symbols
		],
		"productions": [
			@@productions
		],
		"goal": @@goal
	};

	this.lexer = {
		"select": [
			@@dfa-select
		],
		"index": [
@@dfa-index
		],
		"chars": [
@@dfa-char
		],
		"transitions": [
@@dfa-trans
		],
		"accept": [
@@dfa-accept
		]
	};

	this.parser = {
		"action": [
@@action-table
		],
		"goto": [
@@goto-table
		],
		"default-production": [
			@@default-productions
		]
	};
}


// Get character
@@prefixParser.prototype.get_char = function(pcb) {
	// Get next character from input stream
	if( typeof pcb.input === "function" )
		return pcb.input();

	if( pcb.input.length > 0 ) {
		ch = pcb.input[0];
		pcb.input = pcb.input.slice(1);
	}
	else
		ch = pcb.eof;

	return ch;
}

@@prefixParser.prototype.get_input = function(pcb, offset) {
	// Input buffering
	while( offset &gt;= pcb.buf.length ) {
		if( pcb.is_eof )
			return pcb.eof;

		ch = this.get_char(pcb);
		if( ch == pcb.eof ) {
			pcb.is_eof = true;
			return pcb.eof;
		}

		pcb.buf += ch;
	}

	//console.log("get_input %s, %d, %s, %d", pcb.buf, offset, pcb.buf.charAt(offset), pcb.buf.charCodeAt(offset))

	return pcb.buf.charCodeAt(offset);
}

@@prefixParser.prototype.clear_input = function(pcb) {
	// Purge input from buffer that is not necessary anymore

	if( pcb.buf.length ) {
		// Perform position counting.
		for( var pos = 0; pos &lt;= pcb.len; pos++ ) {
			if( pcb.buf[pos] == '\n' ) {
				pcb.line++;
				pcb.column = 0;
			}
			else
				pcb.column++;
		}

		pcb.buf = pcb.buf.slice( pcb.len );
	}

	pcb.len = 0;
	pcb.sym = -1;
}

@@prefixParser.prototype.lex = function(pcb) {
	// Perform lexical analysis
	var state = 0, length = 0;

	machine = Boolean(@@mode) ? 0 : this.lexer["select"][pcb.tos.state];
	next = this.get_input(pcb, length);

	if( next == pcb.eof ) {
		pcb.sym = @@eof;
		return;
	}

	while( state &gt; -1 &amp;&amp; next != pcb.eof ) {
		var idx = this.lexer["index"][machine][state];
		state = -1;

		while( this.lexer["chars"][idx * 2] &gt; -1 ) {
			if( next &gt;= this.lexer["chars"][idx * 2]
					&amp;&amp; next &lt;= this.lexer["chars"][idx * 2 + 1] ) {

				length++;
				state = this.lexer["transitions"][idx];

				if( this.lexer["accept"][machine][state] &gt; 0 ) {
					pcb.sym = this.lexer["accept"][machine][state] - 1;
					pcb.len = length;

					// Test! (??)
					if( pcb.sym == @@eof ) {
						state = -1;
						break;
					}

					// Stop if matched symbol should be parsed nongreedy
					if( !Boolean(this.grammar["symbols"][pcb.sym]["is-greedy"]) ) {
						state = -1;
						break;
					}
				}

				next = this.get_input(pcb, length);
				break;
			}

			idx++;
		}

		// TODO: Semantic Terminal Selection?
	}

	//console.log("lex sym = %d, len = %d", pcb.sym, pcb.len);
}

@@prefixParser.prototype.get_sym = function(pcb) {
	// Get lookahead symbol
	pcb.sym = -1;
	pcb.len = 0;

	// insensitive mode
	if( Boolean(@@mode) )
		while( true )
		{
			this.lex(pcb);

			// check for whitespace
			if( pcb.sym &gt; -1 &amp;&amp; Boolean(this.grammar["symbols"][pcb.sym]["is-whitespace"]) ) {
				this.clear_input(pcb);
				continue;
			}

			break;
		}

	// sensitive mode
	else if( this.lexer["select"][pcb.tos.state] &gt; -1 )
		this.lex(pcb);

	// If there is no matching DFA state machine, try to identify the
	// end-of-file symbol. If this also fails, a parse error will raise.
	else if( this.get_input(pcb, 0) == pcb.eof )
		pcb.sym = @@eof;

	return Boolean(pcb.sym &gt; -1);
}

@@prefixParser.prototype.parse = function(s) {
	// Constants
	const ERROR = 0;
	const REDUCE = 1;
	const SHIFT = 2;

	// Start of parse function
	pcb = new @@prefixParserControlBlock()
	pcb.input = s

	pcb.tos = new @@prefixParserToken()
	pcb.stack.push(pcb.tos)

	while( true ) {
		//console.log("state = %d", pcb.tos.state);

		// Reduce
		while( pcb.act &amp; REDUCE ) {
			// Set default left-hand side
			pcb.lhs = this.grammar["productions"][pcb.idx]["left-hand-side"];

			//console.log("REDUCE idx = %d, prod = %s", pcb.idx, this.grammar["productions"][pcb.idx]["production"]);
			// print("state", pcb.tos.state);

			// Call reduce function
			//console.log("CALL", "_reduce_action_%d" % pcb.idx)

			if( ( "parse_" + pcb.idx ) in pcb )
				pcb[ "parse_" + pcb.idx ]();

			// Drop right-hand side
			var cnodes = null, node = null;

			for( var i = 0; i &lt; this.grammar["productions"][pcb.idx]["length"]; i++ ) {
				item = pcb.stack.pop();

				if( item.node )
				{
					if( cnodes === null )
						cnodes = [];

					if( Array.isArray( item.node ) )
						cnodes = item.node.concat(cnodes);
					else
						cnodes.unshift(item.node);
				}
			}

			pcb.tos = pcb.stack[pcb.stack.length - 1];
			pcb.tos.value = pcb.ret;

			// Handle AST nodes
			if( Boolean( this.grammar["productions"][pcb.idx]["emit"] ) ) {
				//console.log("%s = %s", this.grammar["productions"][pcb.idx]["production"], this.grammar["productions"][pcb.idx]["emit"]);

				node = new @@prefixNode(this.grammar["productions"][pcb.idx]["emit"], null, cnodes);
			}

			// Goal symbol reduced, and stack is empty?
			if( pcb.lhs == @@goal &amp;&amp; pcb.stack.length == 1 ) {
				pcb.tos.node = node ? node : cnodes;
				this.clear_input(pcb);
				break;
			}

			// Get goto table entry
			pcb.act = this.parser["goto"][pcb.tos.state][pcb.lhs][0];
			pcb.idx = this.parser["goto"][pcb.tos.state][pcb.lhs][1];

			pcb.tos = new @@prefixParserToken();
			pcb.stack.push(pcb.tos)

			pcb.tos.symbol = this.grammar["symbols"][pcb.lhs];
			pcb.tos.state = pcb.act &amp; REDUCE ? -1 : pcb.idx;
			pcb.tos.value = pcb.ret;

			pcb.tos.node = node ? node : cnodes;
			pcb.tos.value = pcb.ret;

			pcb.tos.line = pcb.line;
			pcb.tos.column = pcb.column;
		}

		if( pcb.act &amp; REDUCE &amp;&amp; pcb.idx == @@goal-production )
			break;

		// Get next input symbol
		this.get_sym(pcb);

		//console.log("pcb.sym = %d (%s)", pcb.sym, this.grammar["symbols"][pcb.sym]["symbol"]);
		//console.log("pcb.len = %d", pcb.len);

		// Get action table entry
		if( pcb.sym in this.parser["action"][pcb.tos.state] ) {
			pcb.act = this.parser["action"][pcb.tos.state][pcb.sym][0];
			pcb.idx = this.parser["action"][pcb.tos.state][pcb.sym][1];
		} else {
			// Otherwise, apply default production
			pcb.idx = this.parser["default-production"][pcb.tos.state];

			if( pcb.idx &gt; -1 ) {
				pcb.act = REDUCE;
			}
			else {
				pcb.act = 0;
			}
		}

		if( !pcb.act ) {
			// TODO: Error Recovery

			console.log( "Parse error" );
			/*
			raise @@prefixParseException(pcb.line, pcb.column,
				[self._symbols[sym]
					for (sym, pcb.act, pcb.idx)
						in self._act[pcb.tos.state]])
			*/
			return false;
		}

		// Shift
		if( pcb.act &amp; SHIFT ) {
			//console.log("SHIFT sym = %d (%s)", pcb.sym, this.grammar["symbols"][pcb.sym]["symbol"]);

			pcb.tos = new @@prefixParserToken();
			pcb.stack.push(pcb.tos);

			// Execute scanner actions, if existing.
			if( ( "scan_" + pcb.idx ) in pcb )
				pcb[ "parse_" + pcb.idx ]();

			pcb.tos.state = pcb.act &amp; REDUCE ? -1 : pcb.idx;
			pcb.tos.symbol = this.grammar["symbols"][pcb.sym];

			pcb.tos.line = pcb.line;
			pcb.tos.column = pcb.column;
			@@top-value = pcb.buf.slice(0, pcb.len);

			if( Boolean( pcb.tos.symbol["emit"] ) )
				pcb.tos.node = new @@prefixNode(pcb.tos.symbol["emit"], @@top-value);

			if( pcb.sym != @@eof &amp;&amp; pcb.sym != @@error ) {
				this.clear_input(pcb);
				pcb.old_sym = -1
			}
		}
	}

	if( !pcb.ret &amp;&amp; pcb.tos.node ) {
		if( Array.isArray( pcb.tos.node ) ) {
			if( pcb.tos.node.length &gt; 1 )
				node = new @@prefixNode(null, null, pcb.tos.node);
			else
				node = pcb.tos.node.pop();
		}
		else
			node = pcb.tos.node;

		return node;
	}

	return pcb.ret;
}

@@epilogue
</file>
</generator>
