<?xml version="1.0" standalone="yes"?>
<!--
This template should serve as a general description and reference of how
templates for the UniCC parser generator's static build-in code generator
may be described.

It should be possible to abstract this template and given expansion macros
to several other programming languages, not only C-like ones.

In this template, there are many expansion macros used. Expansion macros begin
with "@@" and a followed identifier. These macros are expaned in several stages,
some macros represent values that directly come from the code generator, other
macros define code-parts that had already been constructed by subsequent
construction stages and are inserted in particular positions. All macros are
pre-defined by the UniCC program module generator, is is not possible to build
own expansion macros or deviating construction logics due the statical structure
of the UniCC program module generator.

The expansion macro @@prefix holds the prefix which is possibly defined for a
grammar.

No XML-tag is 'really' required. UniCC will drop a warning when it misses a tag,
but continues code generation with the tags it finds.

Some of the following comments begin with 1D TABLE or 2D TABLE. A 1D TABLE
expands into an one-dimensional array, a 2D TABLE into a two-dimensional array;
To obtain the sizes for both dimensions, there are expanding macros both in the
<file>-tag and related to every table.

1D Tables always consist of a <col> and a <col_sep> tag.
2D Tables always consist of a <row_start>, <row_end>, <row_sep>, <col> and a
<col_sep> tag. <row_sep> and <col_sep> define separators that will be inserted
between the rows/columns, except the last row/column.
-->

<generator name="C">
    <!--
    ****************************************************************************
    Boolean values
    ****************************************************************************
    Values for booleans.
    -->
    <true>1</true>
    <false>0</false>

    <!--
    ****************************************************************************
    Escape sequences
    ****************************************************************************
    These are the escapable sequence definitions for the target language
    which should be replaced when terminal-/nonterminal (especially generated
    ones) names are generated into the target file, e.g. in the <symbols>-tag.
    -->

    <!-- Backslash must be double-quoted -->
    <escape-sequence for="\" do="\\" />
    <!-- Escape double quotation marks -->
    <escape-sequence for="&#x22;" do="\&#x22;" />

    <!--
    ****************************************************************************
    Value-stack templates
    ****************************************************************************
    -->

    <!-- Default (return) value type for nonterminals -->
    <vstack_def_type>int</vstack_def_type>
    <!-- Default value type for character-class terminals -->
    <vstack_term_type>int</vstack_term_type>

    <!--
    Code to be generated for the value stack datatype-definition
    when only one datatype is used within the whole grammar (or if
    always the default-type is used).

    Placeholders:	@@value-type			- 	Expands to the type-declaration
                                                of the only used value type.
    -->
    <vstack_single>typedef @@value-type @@prefix_vtype;</vstack_single>

    <!--
    Begin and end of code to be generated for the value stack
    datatype-definition when multiple datatypes are used within the
    whole grammar.  Note that you can define here even struct-like
    code or array-like structure if your target language supports
    only those.

    Placeholders:	@@number-of-value-types	-	Expands to the maximum number
                                                of value types possible here.
                                                Can be used in both of the
                                                following tags.
    -->
    <vstack_union_start>typedef union @@prefix_VTYPE&#x0A;{&#x0A;</vstack_union_start>
    <vstack_union_end>} @@prefix_vtype;&#x0A;&#x0A;</vstack_union_end>

    <!--
    This tag defines a data type definition within the union.
    As @@attribute, the content of the <vstack_union_att>-tag is expanded,
    which then contains a consecutive number of the datatype.
    This block is repeated for every value type within the union/whatever ;)

    Placeholders:	@@value-type			- 	Expands to the type-declaration
                                                of the current data type as
                                                specified within the grammar.
                    @@attribute				-	As @@attribute, the content
                                                of the <vstack_union_att>-tag
                                                is expanded, which then
                                                contains a consecutive number
                                                of the datatype.
                    @@value-type-id			-	The value type ID, which begins
                                                at 0. This can be the index of
                                                an array!
    -->
    <vstack_union_def>    @@value-type @@attribute;&#x0A;</vstack_union_def>

    <!--
    This tag defines is used in several code-generation parts, both when
    the value stack union is defined and when reduction code for productions
    is produced.

    Placeholders:	@@value-type-id			-	The value type ID, which
                                                begins at 0.
                                                This can be the index of
                                                an array!
    -->
    <vstack_union_att>value_@@value-type-id</vstack_union_att>

    <!--
    ****************************************************************************
    Semantic action templates
    ****************************************************************************
    -->

    <!--
    Begin and end of code to be generated for each reduction code action of a
    production. This code is embedded to a switch-structure below, every block
    is a "case" within this switch. <action_start> is generated BEFORE and
    <action_end> BEHIND each reduction code.

    Placeholders:	@@production-number		-	The number of the production to
                                                be reduced. Can be used in both
                                                of the following tags.
    -->
    <action_start>            case @@production-number:&#x0A;                    {&#x0A;                    </action_start>
    <action_end>    ;&#x0A;                    }&#x0A;                    break;
    </action_end>

    <!--
    Single value access when only one datatype is used in the whole grammar.

    Placeholders:	@@offset				-	The number of the right-hand
                                                side symbol to be accessed.
                                                This is the number specified in
                                                the production reduction code
                                                as number or even by the
                                                right-hand side element's
                                                identifier. The offset is
                                                inserted here by UniCC's
                                                code generator.
    -->
    <action_single>( ( pcb->tos - @@offset )->value )</action_single>

    <!--
    Multiple value access, in case of different datatypes used within the
    grammar.

    Placeholders:	@@offset				-	The number of the right-hand
                                                side symbol to be accessed.
                                                This is the number specified in
                                                the production reduction code
                                                as number or even by the
                                                right-hand side element's
                                                identifier. The offset is
                                                inserted here by UniCC's
                                                code generator.
                    @@attribute				-	As @@attribute, the content of
                                                the <vstack_union_att>-tag is
                                                expanded, which then contains
                                                a consecutive number of the
                                                datatype.
    -->
    <action_union>( ( pcb->tos - @@offset )->value.@@attribute )</action_union>

    <!--
    Single value left-hand side assignment variable when only one datatype
    is used in the whole grammar.

    Placeholders:	none
    -->
    <action_lhs_single>pcb->ret</action_lhs_single>

    <!--
    Multiple value left-hand side assignment variable when different
    datatypes are used within the whole grammar.

    Placeholders:	@@attribute				-	As @@attribute, the content of
                                                the <vstack_union_att>-tag is
                                                expanded, which then contains
                                                a consecutive number of the
                                                datatype.
    -->
    <action_lhs_union>pcb->ret.@@attribute</action_lhs_union>

    <!--
    This template will be triggered when a semantic action selects a
    left-hand side. By default, the primary left-hand side will be replaced
    by the production after reduction. This can be changed by using the
    @$<name>-placeholders in semantic actions.

    Only defined left-hand sides for the production can be associated.

    Placeholders:	@@sym					-	Will be replaced by the
                                                symbol-id of the specified
                                                left-hand side symbol.
    -->
    <action_set_lhs>( pcb->lhs = @@sym )</action_set_lhs>

    <!--
    ****************************************************************************
    Semantic terminal action templates
    ****************************************************************************
    -->

    <!--
    Begin and end of code to be generated for each match of a regular
    expression token. This code is embedded to a switch-structure below,
    every block is a "case" within this switch. <scan_action_start> is
    generated BEFORE and <scan_action_end> BEHIND each reduction code.

    The code here is only produced when the matched regex-terminal contains
    individual code segments.

    Placeholders:	@@symbol-number			-	The id of the terminal the
                                                lexical analyzer action belongs
                                                to. Can be used in both of the
                                                following tags.
    -->

    <scan_action_start>                case @@symbol-number:&#x0A;                {&#x0A;                    </scan_action_start>
    <scan_action_end>    ;&#x0A;                }&#x0A;                    break;
    </scan_action_end>

    <!--
    The content of the tags <scan_action_begin_offset> and
    <scan_action_end_offset> are inserted in regex-terminal semantic code
    blocks for the placeholders @> and @< to get the start-address and
    length of the matched string. Normally, these are variable names.

    Placeholders:	none
    -->
    <scan_action_begin_offset>@@prefix_lexem( pcb )</scan_action_begin_offset>
    <scan_action_end_offset>pcb->len</scan_action_end_offset>

    <!--
    When @@ is used in regex-terminal semantic code blocks, a variable that
    receives the semantic value of the token to be pushed to the value stack
    must be given. For single value assignments,this is done here.
    This value is only used when the grammar uses only one datatype.

    Placeholders:		none
    -->
    <scan_action_ret_single>pcb->tos->value</scan_action_ret_single>

    <!--
    Same play for multiple value assignments in regex-terminal semantic action blocks.

    Placeholders:	@@attribute				-	As @@attribute, the content of
                                                the <vstack_union_att>-tag is
                                                expanded, which then contains
                                                a consecutive number of the
                                                datatype.
    -->
    <scan_action_ret_union>( pcb->tos->value.@@attribute )</scan_action_ret_union>

    <!--
    This template is used when there is a semantic action-based
    regular expression terminal decision. This is equivalent to the
    selection of left-hand side in semantic production actions above.

    Placeholders:	@@sym				-		The symbol-id of the requested
                                                terminal symbol will be inserted
                                                here.
    -->
    <scan_action_set_symbol>( pcb->sym = @@sym )</scan_action_set_symbol>

    <!--
    ****************************************************************************
    Parse table templates
    ****************************************************************************
    -->

    <!-- 1D TABLE
    The <defprod>-tag defines an one-dimensional array for the id's of
    the default productions that should be reduced when no other action
    is selected. UniCC choses the default production by the most common
    reduction that comes up. All reductions which belong to that production
    are removed from the action table, so that the default table is chosen.
    The following Placeholders can only be used in the <col>-tag below
    <defprod>.

    Placeholders:	@@state-number			-	The id-number of the state
                                                where the default production
                                                belongs to.
                    @@production-number		-	The production id number
                                                indexing the production.
                                                This can be automatically
                                                solved via the array index
                                                itself. The production
                                                numbers begins at 0.
                                                If there is no adequate
                                                default-production, the
                                                production-number will be
                                                -1.
    -->
    <defprod>
        <col>    @@production-number</col>
        <col_sep>,&#x0A;</col_sep>
    </defprod>

    <!-- 2D TABLE
    The <acttab>-tag expands to the parser action table. The action table
    describes the parser actions for every state and lookahead-symbol
    combination (resp. state-terminal combination).

    Placeholders:	@@number-of-columns		-	Total number of columns
                                                for every entry. Can only
                                                be used in <row_start> and
                                                <row_end>.
                    @@row					-	The row index, beginning
                                                at 0. Can only be used in
                                                <row_start> and <row_end>.
                    @@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@symbol				-	Lookahead-symbol ID for
                                                each entry column, can only
                                                be used in <col>.
                    @@action				-	The action for each entry
                                                column, can only be used in
                                                <col>. This expands to
                                                1 for reduce,
                                                2 for shift and
                                                3 for shift&reduce.
                    @@index					-	The number of the next state
                                                in case of a shift, or the
                                                number of the reduction
                                                action in case of a reduce
                                                or shift&reduce action.
    -->
    <acttab>
        <row_start>    {&#x0A;        @@number-of-columns</row_start>
        <row_end>&#x0A;    }</row_end>
        <row_sep>,&#x0A;</row_sep>
        <col>,&#x0A;        @@symbol, @@action, @@index</col>
        <col_sep></col_sep>
    </acttab>

    <!-- 2D TABLE
    The <gotab>-tag expands to the parser goto table. The goto table
    describes the parser actions to be performed on a state and
    nonterminal-symbol combination right after a reduction.

    Placeholders:	@@number-of-columns		-	Total number of columns
                                                for every entry. Can only
                                                be used in <row_start> and
                                                <row_end>.
                    @@row					-	The row index, beginning
                                                at 0. Can only be used in
                                                <row_start> and <row_end>.
                    @@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@symbol				-	Nonterminal-symbol ID for
                                                each entry column, can only
                                                be used in <col>.
                    @@action				-	The action for each entry
                                                column, can only be used in
                                                <col>. This expands to
                                                2 for shift and
                                                3 for shift&reduce.

                                                A reduce-only will never be
                                                the case.
                    @@index					-	The number of the next state.
    -->
    <gotab>
        <row_start>    {&#x0A;        @@number-of-columns</row_start>
        <row_end>&#x0A;    }</row_end>
        <row_sep>,&#x0A;</row_sep>
        <col>,&#x0A;        @@symbol, @@action, @@index</col>
        <col_sep></col_sep>
    </gotab>


    <!--
    ****************************************************************************
    Lexical analyzer table templates
    ****************************************************************************
    UniCC constructs one single lexical analyzer in insensitive mode, and
    several lexical analyzers in sensitive mode, that must be selected for every
    LALR-state.

    Several states may use the same lexical analyzer, so there is a table to
    select the lexical analyzer from, relating to every LALR-state.
    A lexical analyzer is a deterministic finite-state machine (DFA) that is
    pre-calculated by UniCC and used to identify tokens from the input,
    according to context-valid possibilities (sensitive mode) or globally
    (insensitive mode).
    -->

    <!-- 1D TABLE
    The <dfa_select>-tag expands to a table that hold the index of the lexical
    analyzer for every LALR-state.

    Placeholders:	@@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@machine				-	Expand to the index of the state
                                                machine for the LALR-state.
                                                Index begins at 0.
    -->
    <dfa_select>
        <col>        @@machine</col>
        <col_sep>,&#x0A;</col_sep>
    </dfa_select>

    <!-- 1D TABLE
    The <dfa_char>-tag expands to a table that hold all the characters for all
    states, where a character-range with @@from = -1 and @@to = -1 defines the
    end of a state character range definition.

    Placeholders:	@@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@from					-	Character-code from
                    @@to					-	Character-code to
    -->
    <dfa_char>
        <col>        @@from, @@to</col>
        <col_sep>,&#x0A;</col_sep>
    </dfa_char>

    <!-- 1D TABLE
    The <dfa_trans>-tag expands to a table that hold all the transitions
    to the next DFA state if a character range from <dfa_char> matches.

    Placeholders:	@@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@goto					-	Next state to go to.
    -->
    <dfa_trans>
        <col>        @@goto</col>
        <col_sep>,&#x0A; </col_sep>
    </dfa_trans>


    <!-- 2D TABLE
    The <dfa_idx>-tag expands to a table that hold for every lexical analyzer
    DFA a table with the offsets of the character-ranges in table <dfa_char>.

    Placeholders:	@@row					-	The row index, beginning
                                                at 0. Can only be used in
                                                <row_start> and <row_end>.
                    @@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@index					-	Beginning offset of the state,
                                                must be multiplied by 2 to
                                                get the correct index in most
                                                cases.
                    @@number-of-columns		-	Number of DFA states for the
                                                given DFA state machine.
    -->
    <dfa_idx>
        <row_start>    {&#x0A;</row_start>
        <row_end>&#x0A;    }</row_end>
        <row_sep>,&#x0A;</row_sep>
        <col>        @@index * 2</col>
        <col_sep>,&#x0A;</col_sep>
    </dfa_idx>

    <!-- 2D TABLE
    The <dfa_accept>-tag expands to a table that hold accepting symbol
    identifier tables for every DFA state.

    Placeholders:	@@row					-	The row index, beginning
                                                at 0. Can only be used in
                                                <row_start> and <row_end>.
                    @@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@accept				-	Accepting ID of the terminal
                                                symbol that is probably
                                                matched until this state by
                                                the lexical analyzer.
                    @@number-of-columns		-	Number of DFA states for the
                                                given DFA state machine.
    -->
    <dfa_accept>
        <row_start>    {&#x0A;</row_start>
        <row_end>&#x0A;    }</row_end>
        <row_sep>,&#x0A;</row_sep>
        <col>        @@accept</col>
        <col_sep>,&#x0A;</col_sep>
    </dfa_accept>

    <!--
    ****************************************************************************
    Symbol and production information tables
    ****************************************************************************
    -->

    <!-- 1D TABLE
    The <symbol>-tag expands to a symbol information table that has an
    entry for each grammar symbol (intermixed terminal and nonterminal),
    which may contain its definition string or name, its type, its data-type
    index and several symbol-related flags. The table is not required for
    the parsing, but used for debug/trace and extended possibilites, e.g.
    automatically generated syntax trees.

    Placeholders:	@@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@greedy				- 	1, if the symbol is a regular
                                                expression terminal and should
                                                be parsed greedy, 0 if not.
                    @@lexem					-	1, if the symbol is configured
                                                as a lexem, 0 if not.
                    @@symbol				-	The ID of the symbol.
                    @@symbol-name			-	The symbol string of the symbol,
                                                which is escaped by the escape
                                                sequences defined on top.
                    @@type					-	The symbol type:
                                                0) Nonterminal
                                                1) Character-class terminal
                                                2) Regex-class terminal
                                                3) String-class terminal
                    @@whitespace			-	1, if the symbol is configured
                                                as whitespace symbol, 0 if not.
    -->
    <symbols>
        <col>	{ /* @@symbol */ "@@symbol-name", "@@emit", @@type, @@lexem, @@whitespace, @@greedy }</col>
        <col_sep>,&#x0A;</col_sep>
    </symbols>

    <!-- 1D TABLE
    The <production>-tag expands to a production information table that has an
    entry for every production, which may contain its definition string, length
    and default left-hand side. This table is not required for the parsing, but
    used for debug/trace and extended possibilites, e.g. automatically
    generated syntax trees.

    Placeholders:	@@column				-	The column index, beginning
                                                at 0. Can only be used in
                                                <col>.
                    @@production-number		-	The ID of the production.
                    @@production			-	The production string,
                                                which is escaped by the escape
                                                sequences defined on top.
                    @@length				-	The length of the production
                                                (symbols on the right-hand
                                                side)
                    @@lhs					-	Default left-hand side.
                                                Multiple left-hand sides are
                                                not covered here.
    -->
    <productions>
        <col>	{ /* @@production-number */ "@@production", "@@emit", @@length, @@lhs }</col>
        <col_sep>,&#x0A;</col_sep>
    </productions>

    <!--
    The <code_localization>-tag is printed before every line of semantic
    code, and equipped with some information about the source. Programming
    languages like C support a way to let the compiler report other locations
    in generated files, like it is the case with UniCC.

    Placeholders:	@@line					-	The first line number where the
                                                semantic code was parsed at.
                    @@filename				-	The filename, where the semantoc
                                                code has been parsed from (this
                                                is the name of the parser
                                                definition file)
    -->
    <code_localization>#line @@line "@@filename"
</code_localization>


    <!--
    Now, the output files are described. It can be one file or multiple, all
    allow the insertion of the same placeholers.

    Placeholders:	@@actions				-	Inserts the parser action code
                                                that is constructed from the
                                                program code attached to
                                                productions in combination with
                                                the tags
                                                <action_start> and <action_end>
                    @@action-table			-	Inserts the expanded action
                                                table that is generated from the
                                                <acttab> tags.
                    @@basename				-	The basename of the target file.
                    @@Cbasename				-	The basename of the target file,
                                                as C-identifier. For example,
                                                "test.1" becomes "test_1".
                    @@CBASENAME				-	The basename of the target file,
                                                as C-identifier, in upper case
                                                order. For example,
                                                "test.1" becomes "TEST_1".
                    @@character-universe		-	Upper limit of the character
                                                universe. Lowest limit is
                                                always 0.
                    @@copyright_len			-	The length of the content of
                                                the #copyright parser directive.
                    @@copyright				-	Content of the #copyright
                                                parser directive.
                    @@deepest-action-row		-	Number of elements in the
                                                deepest row of the expanded
                                                array of the <acttab>-tag.
                                                This should be used for array
                                                memory allocation.
                    @@deepest-dfa-accept-row-	Number of elements in the
                                                deepest row of the expanded
                                                array of the <dfa_accept>-tag.
                                                This is used for array memory
                                                allocation.
                    @@deepest-dfa-index-row	-	Number of elements in the
                                                deepest row of the expanded
                                                array of the <dfa_idx>-tag.
                                                This is used for array memory
                                                allocation.
                    @@deepest-goto-row		-	Number of elements in the
                                                deepest row of the expanded
                                                array of the <gotab>-tag.
                                                This should be used for array
                                                memory allocation.
                    @@default-productions	-	Expands to the array of
                                                default productions from the
                                                <defprod>-tag.
                    @@description_len		-	The length of the content of
                                                the #description parser
                                                directive.
                    @@description			-	Content of the #description
                                                parser directive.
                    @@dfa-accept			-	Expands to the array of
                                                DFA accepting states from the
                                                <dfa_accept>-tag.
                    @@dfa-char				-	Expands to the array of DFA
                                                state characters from the
                                                <dfa_char>-tag.
                    @@dfa-index				-	Expands to the array of
                                                DFA state indexes from the
                                                <dfa_idx>-tag.
                    @@dfa-select				-	Expands to the array of
                                                DFA machine selection from the
                                                <dfa_select>-tag.
                    @@dfa-trans				-	Expands to the array of
                                                DFA transitions from the
                                                <dfa_trans>-tag.
                    @@eof					-	The symbol ID of the end-of-file
                                                terminal symbol. This is -1
                                                if not defined.
                    @@epilogue_len			-	The length of the content of
                                                the #epilogue parser
                                                directive.
                    @@epilogue				-	Content of the #epilogue
                                                parser directive.
                    @@error					-	The symbol ID of the error
                                                resynchrinoization terminal
                                                This is -1 if not defined.
                    @@filename_len			-	The length of the parser source
                                                filename.
                    @@filename				-	The filename of the parser
                                                source file.
                    @@goal					-	The symbol ID of the goal
                                                symbol (always a nonterminal).
                    @@goal-production		-	The production ID of the
                                                goal production.
                    @@goto-table			-	Inserts the expanded goto table
                                                that is generated from the
                                                <gotab> tags.
                    @@max-symbol-name-length-	Maxiumum size of the longest
                                                symbol name that was generated
                                                in the <symbols>-tag.
                    @@mode					-	The parser construction mode;
                                                0 for senstivie mode,
                                                1 for insensitive mode

                    @@name_len				-	The length of the content of
                                                the #parser parser
                                                directive.
                    @@name					-	Content of the #parser
                                                parser directive.
                    @@number-of-dfa-machines-	Total number of DFA state
                                                machines. This is always 1
                                                in insentivie parsers.
                    @@number-of-productions	-	The number of productions.
                    @@number-of-states		-	The number of LALR(1) states.
                    @@number-of-symbols		-	The number of symbols.
                    @@pcb_len				-	The length of the content of
                                                the #pcb parser directive.
                    @@pcb					-	Content of the #pcb
                                                parser directive.
                    @@productions			-	Expands to the productions
                                                string array produced by
                                                the <productions>-tag.
                    @@prologue_len			-	The length of the content of
                                                the #prologue parser
                                                directive.
                    @@prologue				-	Content of the #prologue
                                                parser directive.
                    @@scan_actions			-	Expands to the semantic
                                                scanner actions that may
                                                be processed when a token
                                                has been correctly matched.
                    @@size-of-dfa-characters-	The size of the array
                                                expaned by <dfa_char>.
                    @@symbols				-	Expands to the symbol
                                                string array produced by
                                                the <symbols>-tag.
                    @@top-value				-	Expands to the variable
                                                pointing to the top of
                                                the value-stack.
                    @@value-type-definition	-	Expands to the value type
                                                definitions.
                    @@version_len			-	The length of the content of
                                                the #version parser
                                                directive.
                    @@version				-	Content of the #version
                                                parser directive.

    The expansion macros @@basename, @@Cbasename, @@CBASENAME, @@filename,
    @@filename_len and @@prefix can be used everywhere in all tags. They are
    replaced as last. They can also be used in semantic actions defined in the
    parser's semantic actions. It is also possible to use the above macros in
    the filename-attribute of the file-tag, to generate adequate filenames.
    -->
    <file filename="@@basename.c">/*
    This parser module was generated by unicc from @@filename.
    DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
*/

#if @@prologue_len == 0
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#else
@@prologue
#endif

/* Include parser control block definitions */
#include "@@basename.h"

/* Action Table */
UNICC_STATIC int @@prefix_act[ @@number-of-states ][ @@deepest-action-row * 3 + 1 ] =
{
@@action-table
};

/* GoTo Table */
UNICC_STATIC int @@prefix_go[ @@number-of-states ][ @@deepest-goto-row * 3 + 1 ] =
{
@@goto-table
};

/* Default productions per state */
UNICC_STATIC int @@prefix_def_prod[ @@number-of-states ] =
{
@@default-productions
};

#if !@@mode
/* DFA selection table */
UNICC_STATIC int @@prefix_dfa_select[ @@number-of-states ] =
{
@@dfa-select
};
#endif

#if @@number-of-dfa-machines
/* DFA index table */
UNICC_STATIC int @@prefix_dfa_idx[ @@number-of-dfa-machines ][ @@deepest-dfa-index-row ] =
{
@@dfa-index
};

/* DFA transition chars */
UNICC_STATIC int @@prefix_dfa_chars[ @@size-of-dfa-characters * 2 ] =
{
@@dfa-char
};

/* DFA transitions */
UNICC_STATIC int @@prefix_dfa_trans[ @@size-of-dfa-characters ] =
{
@@dfa-trans
};

/* DFA acception states */
UNICC_STATIC int @@prefix_dfa_accept[ @@number-of-dfa-machines ][ @@deepest-dfa-accept-row ] =
{
@@dfa-accept
};

#endif

/* Symbol information table */
UNICC_STATIC @@prefix_syminfo @@prefix_symbols[] =
{
@@symbols
};

/* Production information table */
UNICC_STATIC @@prefix_prodinfo @@prefix_productions[] =
{
@@productions
};

UNICC_STATIC UNICC_SCHAR* @@prefix_lexem( @@prefix_pcb* pcb )
{
#if UNICC_WCHAR || !UNICC_UTF8
    pcb-&gt;lexem = pcb-&gt;buf;
#else
    size_t		size;

    size = wcstombs( (char*)NULL, pcb-&gt;buf, 0 );

    free( pcb-&gt;lexem );

    if( !( pcb-&gt;lexem = (UNICC_SCHAR*)malloc(
            ( size + 1 ) * sizeof( UNICC_SCHAR ) ) ) )
    {
        UNICC_OUTOFMEM( pcb );
        return (UNICC_SCHAR*)NULL;
    }

    wcstombs( pcb-&gt;lexem, pcb-&gt;buf, size + 1 );
#endif

#if UNICC_DEBUG	&gt; 2
    fprintf( stderr, "%s: lexem: pcb-&gt;lexem = &gt;" UNICC_SCHAR_FORMAT "&lt;\n",
                        UNICC_PARSER, pcb-&gt;lexem );
#endif
    return pcb-&gt;lexem;
}


UNICC_STATIC @@prefix_ast* @@prefix_ast_create( @@prefix_pcb* pcb, char* emit,
                                                    UNICC_SCHAR* token )
{
    @@prefix_ast*	node;

    if( !( node = (@@prefix_ast*)malloc( sizeof( @@prefix_ast ) ) ) )
    {
        UNICC_OUTOFMEM( pcb );
        return node;
    }

    memset( node, 0, sizeof( @@prefix_ast ) );

    node-&gt;emit = emit;

    if( token )
    {
        #if !UNICC_WCHAR
        if( !( node-&gt;token = strdup( token ) ) )
        {
            UNICC_OUTOFMEM( pcb );
            free( node );
            return (@@prefix_ast*)NULL;
        }
        #else
        if( !( node-&gt;token = wcsdup( token ) ) )
        {
            UNICC_OUTOFMEM( pcb );
            free( node );
            return (@@prefix_ast*)NULL;
        }
        #endif
    }

    return node;
}

/* Don't report on unused @@prefix_ast_free or @@prefix_ast_print */
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"

UNICC_STATIC @@prefix_ast* @@prefix_ast_free( @@prefix_ast* node )
{
    if( !node )
        return (@@prefix_ast*)NULL;

    @@prefix_ast_free( node-&gt;child );
    @@prefix_ast_free( node-&gt;next );

    if( node-&gt;token )
        free( node-&gt;token );

    free( node );
    return (@@prefix_ast*)NULL;
}

UNICC_STATIC void @@prefix_ast_print( FILE* stream, @@prefix_ast* node )
{
    int 		i;
    static int 	rec;

    if( !node )
        return;

    if( !stream )
        stream = stderr;

    while( node )
    {
        for( i = 0; i &lt; rec; i++ )
            fprintf( stream,  " " );

        fprintf( stream, "%s", node-&gt;emit );

        if( node-&gt;token &amp;&amp; strcmp( node-&gt;emit, node-&gt;token ) != 0 )
            fprintf( stream, " (%s)", node-&gt;token );

        fprintf( stream, "\n" );

        rec++;
        @@prefix_ast_print( stream, node-&gt;child );
        rec--;

        node = node-&gt;next;
    }
}

#pragma GCC diagnostic pop

UNICC_STATIC int @@prefix_get_act( @@prefix_pcb* pcb )
{
    int i;

    for( i = 1; i &lt; @@prefix_act[ pcb-&gt;tos-&gt;state ][0] * 3; i += 3 )
    {
        if( @@prefix_act[ pcb-&gt;tos-&gt;state ][i] == pcb-&gt;sym )
        {
            if( ( pcb-&gt;act = @@prefix_act[ pcb-&gt;tos-&gt;state ][i+1] )
                    == UNICC_ERROR )
                return 0; /* Force parse error! */

            pcb-&gt;idx = @@prefix_act[ pcb-&gt;tos-&gt;state ][i+2];
            return 1;
        }
    }

    /* Default production */
    if( ( pcb-&gt;idx = @@prefix_def_prod[ pcb-&gt;tos-&gt;state ] ) &gt; -1 )
    {
        pcb-&gt;act = 1; /* Reduce */
        return 1;
    }

    return 0;
}

UNICC_STATIC int @@prefix_get_go( @@prefix_pcb* pcb )
{
    int i;

    for( i = 1; i &lt; @@prefix_go[ pcb-&gt;tos-&gt;state ][0] * 3; i += 3 )
    {
        if( @@prefix_go[ pcb-&gt;tos-&gt;state ][i] == pcb-&gt;lhs )
        {
            pcb-&gt;act = @@prefix_go[ pcb-&gt;tos-&gt;state ][ i + 1 ];
            pcb-&gt;idx = @@prefix_go[ pcb-&gt;tos-&gt;state ][ i + 2 ];
            return 1;
        }
    }

    return 0;
}

UNICC_STATIC int @@prefix_alloc_stack( @@prefix_pcb* pcb )
{
    unsigned int	size;

    if( !pcb-&gt;stacksize )
    {
        if( !( pcb-&gt;tos = pcb-&gt;stack = (@@prefix_tok*)malloc(
                UNICC_MALLOCSTEP * sizeof( @@prefix_tok ) ) ) )
        {
            UNICC_OUTOFMEM( pcb );
            return -1;
        }

        pcb-&gt;stacksize = UNICC_MALLOCSTEP;
    }
    else if( ( size = (unsigned int)( pcb-&gt;tos - pcb-&gt;stack ) )
                == pcb-&gt;stacksize )
    {
        @@prefix_tok*	ptr;

        if( !( ptr = (@@prefix_tok*)realloc( pcb-&gt;stack,
                ( pcb-&gt;stacksize + UNICC_MALLOCSTEP )
                    * sizeof( @@prefix_tok ) ) ) )
        {
            UNICC_OUTOFMEM( pcb );
            free( pcb-&gt;stack );

            return -1;
        }

        pcb-&gt;tos = pcb-&gt;stack = ptr;

        pcb-&gt;stacksize += UNICC_MALLOCSTEP;
        pcb-&gt;tos += size;
    }

    return 0;
}

#ifndef UNICC_GETCHAR
#define UNICC_GETCHAR( pcb )  getchar()
#endif

#if UNICC_UTF8
UNICC_STATIC UNICC_CHAR _get_char( _pcb* pcb )
{
    unsigned char first = UNICC_GETCHAR( pcb );

    if ((first &amp; 0x80) == 0)
    {
        // Single-byte ASCII character
        return first;
    }
    else if ((first &amp; 0xE0) == 0xC0)
    {
        // Two-byte sequence (110xxxxx 10xxxxxx)
        unsigned char second = UNICC_GETCHAR( pcb );
        return ((first &amp; 0x1F) &lt;&lt; 6) | (second &amp; 0x3F);
    }
    else if ((first &amp; 0xF0) == 0xE0)
    {
        // Three-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)
        unsigned char bytes[2];

        bytes[0] = UNICC_GETCHAR( pcb );
        bytes[1] = UNICC_GETCHAR( pcb );

        return
            ((first &amp; 0x0F) &lt;&lt; 12)
            | ((bytes[0] &amp; 0x3F) &lt;&lt; 6)
            | (bytes[1] &amp; 0x3F)
        ;
    }
    else if ((first &amp; 0xF8) == 0xF0)
    {
        // Four-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)
        unsigned char bytes[3];

        bytes[0] = UNICC_GETCHAR( pcb );
        bytes[1] = UNICC_GETCHAR( pcb );
        bytes[2] = UNICC_GETCHAR( pcb );

        return
            ((first &amp; 0x07) &lt;&lt; 18)
            | ((bytes[0] &amp; 0x3F) &lt;&lt; 12)
            | ((bytes[1] &amp; 0x3F) &lt;&lt; 6)
            | (bytes[2] &amp; 0x3F)
        ;
    }

    return -1; // Invalid UTF-8 sequence
}
#else
#define @@prefix_get_char( pcb )  UNICC_GETCHAR( pcb )
#endif

UNICC_STATIC UNICC_CHAR @@prefix_get_input( @@prefix_pcb* pcb, unsigned int offset )
{
#if UNICC_DEBUG	&gt; 2
    fprintf( stderr, "%s: get input: pcb-&gt;buf + offset = %p pcb-&gt;bufend = %p\n",
                UNICC_PARSER, pcb-&gt;buf + offset, pcb-&gt;bufend );
#endif

    while( pcb-&gt;buf + offset &gt;= pcb-&gt;bufend )
    {
#if UNICC_DEBUG	&gt; 2
            fprintf( stderr, "%s: get input: requiring more input\n",
                    UNICC_PARSER );
#endif
        if( !pcb-&gt;buf )
        {
            pcb-&gt;bufend = pcb-&gt;buf = (UNICC_CHAR*)malloc(
                ( UNICC_MALLOCSTEP + 1 ) * sizeof( UNICC_CHAR ) );

            if( !pcb-&gt;buf )
            {
                UNICC_OUTOFMEM( pcb );
                return 0;
            }

            *pcb-&gt;buf = 0;
        }
        else if( *pcb-&gt;buf &amp;&amp; !( ( pcb-&gt;bufend - pcb-&gt;buf ) %
                    UNICC_MALLOCSTEP ) )
        {
            unsigned int 	size	= (unsigned int)( pcb-&gt;bufend - pcb-&gt;buf );
            UNICC_CHAR*		buf;

            if( !( buf = (UNICC_CHAR*)realloc( pcb-&gt;buf,
                        ( size + UNICC_MALLOCSTEP + 1 )
                            * sizeof( UNICC_CHAR ) ) ) )
            {
                UNICC_OUTOFMEM( pcb );
                free( pcb-&gt;buf );

                return 0;
            }

            pcb-&gt;buf = buf;
            pcb-&gt;bufend = pcb-&gt;buf + size;
        }

        if( pcb-&gt;is_eof || ( *( pcb-&gt;bufend ) = @@prefix_get_char( pcb ) )
                                    == pcb-&gt;eof )
        {
#if UNICC_DEBUG	&gt; 2
            fprintf( stderr, "%s: get input: can't get more input, "
                        "end-of-file reached\n", UNICC_PARSER );
#endif
            pcb-&gt;is_eof = 1;
            return pcb-&gt;eof;
        }
#if UNICC_DEBUG	&gt; 2
        fprintf( stderr, "%s: get input: read char &gt;%c&lt; %d\n",
                    UNICC_PARSER, (char)*( pcb-&gt;bufend ), *( pcb-&gt;bufend ) );
#endif

#if UNICC_DEBUG	&gt; 2
        fprintf( stderr, "%s: get input: reading character &gt;%c&lt; %d\n",
                    UNICC_PARSER, (char)*( pcb-&gt;bufend ), *( pcb-&gt;bufend ) );
#endif

        *( ++pcb-&gt;bufend ) = 0;
    }

#if UNICC_DEBUG	&gt; 2
    {
        UNICC_CHAR*		chptr;

        fprintf( stderr, "%s: get input: offset = %d\n",
                    UNICC_PARSER, offset );
        fprintf( stderr, "%s: get input: buf = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
                    UNICC_PARSER, pcb-&gt;buf );
        fprintf( stderr, "%s: get input: returning %d\n",
                    UNICC_PARSER, *( pcb-&gt;buf + offset ) );
    }
#endif

    return pcb-&gt;buf[ offset ];
}

UNICC_STATIC void @@prefix_clear_input( @@prefix_pcb* pcb )
{
    int		i;

    if( pcb-&gt;buf )
    {
        if( pcb-&gt;len )
        {
            /* Update counters for line and column */
            for( i = 0; i &lt; pcb-&gt;len; i++ )
            {
                if( (char)pcb-&gt;buf[i] == '\n' )
                {
                    pcb-&gt;line++;
                    pcb-&gt;column = 1;
                }
                else
                    pcb-&gt;column++;
            }

#if UNICC_DEBUG &gt; 2
    fprintf( stderr, "%s: clear input: "
        "Clearing %d characters (%d bytes)\n",
            UNICC_PARSER, pcb-&gt;len, pcb-&gt;len * sizeof( UNICC_CHAR ) );
    fprintf( stderr, "%s: clear input: buf = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
            UNICC_PARSER, pcb-&gt;buf, sizeof( UNICC_CHAR ) );
    fprintf( stderr, "%s: clear input: pcb-&gt;bufend &gt;" UNICC_CHAR_FORMAT "&lt;\n",
            UNICC_PARSER, pcb-&gt;bufend );
#endif

            memmove( pcb-&gt;buf, pcb-&gt;buf + pcb-&gt;len,
                        ( ( pcb-&gt;bufend - ( pcb-&gt;buf + pcb-&gt;len ) ) + 1 + 1 )
                            * sizeof( UNICC_CHAR ) );
            pcb-&gt;bufend = pcb-&gt;buf + ( pcb-&gt;bufend - ( pcb-&gt;buf + pcb-&gt;len ) );

#if UNICC_DEBUG	&gt; 2
    fprintf( stderr, "%s: clear input: now buf = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
                UNICC_PARSER, pcb-&gt;buf, sizeof( UNICC_CHAR ) );
    fprintf( stderr, "%s: clear input: now bufend = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
                UNICC_PARSER, pcb-&gt;bufend, sizeof( UNICC_CHAR ) );
#endif
        }
        else
        {
            pcb-&gt;bufend = pcb-&gt;buf;
            *( pcb-&gt;buf ) = 0;
        }
    }

    pcb-&gt;len = 0;
    pcb-&gt;sym = -1;
#if UNICC_DEBUG	&gt; 2
    fprintf( stderr, "%s: clear input: symbol cleared\n", UNICC_PARSER );
#endif
}

#if @@number-of-dfa-machines
UNICC_STATIC void @@prefix_lex( @@prefix_pcb* pcb )
{
    int 			dfa_st	= 0;
    unsigned int	len		= 0;
    int				chr;
    UNICC_CHAR		next;
#if !@@mode
    int				mach	= @@prefix_dfa_select[ pcb-&gt;tos-&gt;state ];
#else
    int				mach	= 0;
#endif

    next = @@prefix_get_input( pcb, len );
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: next = %d\n", UNICC_PARSER, next );
#endif

    if( next == pcb-&gt;eof )
    {
        pcb-&gt;sym = @@eof;
        return;
    }

    do
    {
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: next = %d\n", UNICC_PARSER, next );
#endif

        chr = @@prefix_dfa_idx[ mach ][ dfa_st ];
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: chr = %d\n", UNICC_PARSER, chr );
#endif

        dfa_st = -1;
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: FIRST next = %d @@prefix_dfa_chars[ chr ] = %d, "
            "@@prefix_dfa_chars[ chr+1 ] = %d\n", UNICC_PARSER, next,
                @@prefix_dfa_chars[ chr ], @@prefix_dfa_chars[ chr + 1 ] );
#endif
        while( @@prefix_dfa_chars[ chr ] &gt; -1 )
        {
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: next = %d @@prefix_dfa_chars[ chr ] = %d, "
        "@@prefix_dfa_chars[ chr+1 ] = %d\n", UNICC_PARSER, next,
            @@prefix_dfa_chars[ chr ], @@prefix_dfa_chars[ chr + 1 ] );
#endif
            if( next &gt;= @@prefix_dfa_chars[ chr ] &amp;&amp;
                next &lt;= @@prefix_dfa_chars[ chr+1 ] )
            {
                dfa_st = *( @@prefix_dfa_trans + ( chr / 2 ) );
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: dfa_st = %d\n", UNICC_PARSER, dfa_st );
#endif
                if( @@prefix_dfa_accept[ mach ][ dfa_st ] &gt; 0 )
                {
                    pcb-&gt;len = len + 1;
                    pcb-&gt;sym = @@prefix_dfa_accept[ mach ][ dfa_st ] - 1;

#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: new accepting symbol pcb-&gt;sym = %d greedy = %d\n",
            UNICC_PARSER, pcb-&gt;sym, @@prefix_symbols[ pcb-&gt;sym ].greedy );
#endif
                    if( pcb-&gt;sym == @@eof )
                    {
                        dfa_st = -1; /* test! */
                        break;
                    }

                    /* Stop if matched symbol should be parsed nongreedy */
                    if( !@@prefix_symbols[ pcb-&gt;sym ].greedy )
                    {
                        dfa_st = -1;
                        break;
                    }
                }

                next = @@prefix_get_input( pcb, ++len );
                break;
            }

            chr += 2;
        }
    }
    while( dfa_st &gt; -1 &amp;&amp; next != pcb-&gt;eof );

    if( pcb-&gt;sym &gt; -1 )
    {
#if UNICC_SEMANTIC_TERM_SEL
        /*
            Execute scanner actions, if existing, but with
            UNICC_ON_SHIFT = 0, so that no memory allocation
            should be performed. This actions should only be
            handled if there are semantic-code dependent
            terminal symbol selections.

            tos is incremented here, if the semantic code
            stores data for the symbol. It won't get lost
            in case of a shift.
        */
        @@prefix_alloc_stack( pcb );
        pcb-&gt;tos++;

        next = pcb-&gt;buf[ pcb-&gt;len ];
        pcb-&gt;buf[ pcb-&gt;len ] = '\0';

#define UNICC_ON_SHIFT 	0
        switch( pcb-&gt;sym )
        {
@@scan_actions

            default:
                break;
        }
#undef UNICC_ON_SHIFT

        pcb-&gt;buf[ pcb-&gt;len ] = next;

        pcb-&gt;tos--;
#endif /* UNICC_SEMANTIC_TERM_SEL */
    }

#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: function exits, pcb-&gt;sym = %d, pcb-&gt;len = %d\n",
            UNICC_PARSER, pcb-&gt;sym, pcb-&gt;len );
#endif
}
#endif

UNICC_STATIC int @@prefix_get_sym( @@prefix_pcb* pcb )
{
    pcb-&gt;sym = -1;
    pcb-&gt;len = 0;

#if @@mode
    do
    {
#endif
#if !@@mode

#if UNICC_DEBUG &gt; 2
        fprintf( stderr, "%s: get sym: state = %d dfa_select = %d\n",
                    UNICC_PARSER, pcb-&gt;tos-&gt;state,
                        @@prefix_dfa_select[ pcb-&gt;tos-&gt;state ] );
#endif

        if( @@prefix_dfa_select[ pcb-&gt;tos-&gt;state ] &gt; -1 )
            @@prefix_lex( pcb );
        /*
         * If there is no DFA state machine,
         * try to identify the end-of-file symbol.
         * If this also fails, a parse error will
         * raise.
         */
        else if( @@prefix_get_input( pcb, 0 ) == pcb-&gt;eof )
            pcb-&gt;sym = @@eof;
#else
        @@prefix_lex( pcb );
#endif /* !@@mode */

#if @@mode

        if( pcb-&gt;sym &gt; -1 &amp;&amp; @@prefix_symbols[ pcb-&gt;sym ].whitespace )
        {
            UNICC_CLEARIN( pcb );
            continue;
        }

        break;
    }
    while( 1 );
#endif /* @@mode */

    return ( pcb-&gt;sym &gt; -1 ) ? 1 : 0;
}

#if UNICC_STACKDEBUG
UNICC_STATIC void @@prefix_dbg_stack( FILE* out,
    @@prefix_tok* stack, @@prefix_tok* tos )
{
    fprintf( out, "%s: Stack Dump: ", UNICC_PARSER );

    for( ; stack &lt;= tos; stack++ )
    {
        fprintf( out, "%d%s%s%s ", stack-&gt;state,
            stack-&gt;symbol ? " (" : "",
            stack-&gt;symbol ? stack-&gt;symbol-&gt;name : "",
            stack-&gt;symbol ? ")" : "" );
    }

    fprintf( out, "\n" );
}
#endif /* UNICC_STACKDEBUG */

UNICC_STATIC int @@prefix_handle_error( @@prefix_pcb* pcb, FILE* @@prefix_dbg )
{
#if UNICC_DEBUG
    int					i;
#endif

    if( !pcb-&gt;error_delay )
    {
#if UNICC_DEBUG
        fprintf( @@prefix_dbg, "%s: !!!PARSE ERROR!!!\n"
                "%s: error recovery: current token %d (%s)\n",
                    UNICC_PARSER, UNICC_PARSER, pcb-&gt;sym,
                        ( ( pcb-&gt;sym &gt;= 0 ) ?
                            @@prefix_symbols[ pcb-&gt;sym ].name :
                                "(null)" ) );

        fprintf( @@prefix_dbg,
                "%s: error recovery: expecting ", UNICC_PARSER );

        for( i = 1; i &lt; @@prefix_act[ pcb-&gt;tos-&gt;state ][0] * 3; i += 3 )
        {
            fprintf( @@prefix_dbg, "%d (%s)%s",
                @@prefix_act[ pcb-&gt;tos-&gt;state ][i],
                @@prefix_symbols[ @@prefix_act[ pcb-&gt;tos-&gt;state ][i] ].name,
                ( i == @@prefix_act[ pcb-&gt;tos-&gt;state ][0] * 3 - 3 ) ?
                        "\n" : ", " );
        }

        fprintf( @@prefix_dbg, "\n%s: error recovery: error_delay is %d, %s\n",
                    UNICC_PARSER, pcb-&gt;error_delay,
                    ( pcb-&gt;error_delay ? "error recovery runs silently" :
                        "error is reported before its recover!" ) );
#endif
    }

#if @@error &lt; 0
    /* No error token defined? Then exit here... */

#if UNICC_DEBUG
    fprintf( @@prefix_dbg,
        "%s: error recovery: No error resync token used by grammar, "
            "exiting parser.\n", UNICC_PARSER );
#endif

    UNICC_PARSE_ERROR( pcb );
    pcb-&gt;error_count++;

    return 1;
#else
    /*
    @@prefix_pcb 		org_pcb;
    */

#if UNICC_DEBUG
    fprintf( @@prefix_dbg, "%s: error recovery: "
        "trying to recover...\n", UNICC_PARSER );
#if UNICC_STACKDEBUG
    @@prefix_dbg_stack( @@prefix_dbg, pcb-&gt;stack, pcb-&gt;tos );
#endif
#endif

    #if 0
    /* Create a copy of original parser control block (maybe later...) */
    memcpy( &amp;org_pcb, pcb, sizeof( @@prefix_pcb ) );
    org_pcb.buf = (char*)malloc( ( strlen( pcb-&gt;buf ) / UNICC_MALLOCSTEP +
                    ( !( strlen( pcb-&gt;buf ) % UNICC_MALLOCSTEP ) ? 1 : 0 ) )
                            * UNICC_MALLOCSTEP );
    strcpy( org_pcb.buf, pcb-&gt;buf );
    #endif

    /* Remember previous symbol, or discard it */
    if( pcb-&gt;error_delay != UNICC_ERROR_DELAY )
        pcb-&gt;old_sym = pcb-&gt;sym;
    else
    {
        pcb-&gt;old_sym = -1;
        pcb-&gt;len = 1;
        UNICC_CLEARIN( pcb );
    }

    /* Try to shift on error resync */
    pcb-&gt;sym = @@error;

    while( pcb-&gt;tos &gt;= pcb-&gt;stack )
    {
#if UNICC_DEBUG
        fprintf( @@prefix_dbg, "%s: error recovery: in state %d, trying "
                "to shift error resync token...\n",
                    UNICC_PARSER, pcb-&gt;tos-&gt;state );
#if UNICC_STACKDEBUG
        @@prefix_dbg_stack( @@prefix_dbg, pcb-&gt;stack, pcb-&gt;tos );
#endif
#endif
        if( @@prefix_get_act( pcb ) )
        {
            /* Shift */
            if( pcb-&gt;act &amp; UNICC_SHIFT )
            {
#if UNICC_DEBUG
                fprintf( @@prefix_dbg, "%s: error recovery: "
                            "error resync shifted\n", UNICC_PARSER );
#endif
                break;
            }
        }

#if UNICC_DEBUG
        fprintf( @@prefix_dbg, "%s: error recovery: failed, "
                    "discarding token '%s'\n", UNICC_PARSER,
                        pcb-&gt;tos-&gt;symbol ?
                            pcb-&gt;tos-&gt;symbol-&gt;name : "NULL" );
#endif

        /* Discard one token from stack */
        /* TODO: Discarded token memory (semantic action) */
        pcb-&gt;tos--;
    }

    if( pcb-&gt;tos &lt;= pcb-&gt;stack )
    {
#if UNICC_DEBUG
    fprintf( @@prefix_dbg, "%s: error recovery: "
                "Can't recover this issue, stack is empty.\n",
                    UNICC_PARSER );
#endif
        UNICC_PARSE_ERROR( pcb );
        pcb-&gt;error_count++;

        return 1;
    }

#if UNICC_DEBUG
    fprintf( @@prefix_dbg, "%s: error recovery: "
                "trying to continue with modified parser state\n",
                    UNICC_PARSER );
#endif

    pcb-&gt;error_delay = UNICC_ERROR_DELAY + 1;

    return 0;

#endif /* @@error &gt;= 0 */
}

@@goal-type @@prefix_parse( @@prefix_pcb* pcb )
{
    @@goal-type			ret;
    int					i;

    @@prefix_ast*		node;
    @@prefix_ast*		lnode;

#if UNICC_DEBUG
    @@prefix_vtype*		vptr;
    FILE* 				@@prefix_dbg;

    @@prefix_dbg = stderr;
#endif

    /* If there is no Parser Control Block given, allocate your own one! */
    if( !pcb )
    {
        if( !( pcb = (@@prefix_pcb*)malloc( sizeof( @@prefix_pcb ) ) ) )
        {
            /* Can't allocate memory */
            UNICC_OUTOFMEM( pcb );
            return (@@goal-type)0;
        }

        memset( pcb, 0, sizeof( @@prefix_pcb ) );
        pcb-&gt;is_internal = 1;
    }
    else
        pcb-&gt;is_internal = 0;

    /* Initialize Parser Control Block */
    pcb-&gt;stacksize = 0;
    if( @@prefix_alloc_stack( pcb ) &lt; 0 )
        return (@@goal-type)0;

    memset( pcb-&gt;tos, 0, sizeof( @@prefix_tok ) );

    pcb-&gt;act = UNICC_SHIFT;
    pcb-&gt;sym = -1;
    pcb-&gt;old_sym = -1;
    pcb-&gt;line = 1;
    pcb-&gt;column = 1;

    memset( &amp;pcb-&gt;test, 0, sizeof( @@prefix_vtype ) );

    /* Begin of main parser loop */
    while( 1 )
    {
        /* Reduce */
        while( pcb-&gt;act &amp; UNICC_REDUCE )
        {
#if UNICC_DEBUG
            fprintf( @@prefix_dbg, "%s: &lt;&lt; "
                    "reducing by production %d (%s)\n",
                        UNICC_PARSER, pcb-&gt;idx,
                            @@prefix_productions[ pcb-&gt;idx ].definition );
#endif
            /* Set default left-hand side */
            pcb-&gt;lhs = @@prefix_productions[ pcb-&gt;idx ].lhs;

            /* Run reduction code */
            memset( &amp;( pcb-&gt;ret ), 0, sizeof( @@prefix_vtype ) );

            switch( pcb-&gt;idx )
            {
@@actions
            }

            /* Drop right-hand side */
            /* TODO: Destructor callbacks? */
            for( i = 0, node = (@@prefix_ast*)NULL;
                    i &lt; @@prefix_productions[ pcb-&gt;idx ].length;
                        i++ )
            {
                if( pcb-&gt;tos-&gt;node )
                {
                    if( node )
                    {
                        while( node-&gt;prev )
                            node = node-&gt;prev;

                        node-&gt;prev = pcb-&gt;tos-&gt;node;
                        pcb-&gt;tos-&gt;node-&gt;next = node;
                    }

                    node = pcb-&gt;tos-&gt;node;
                    pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;
                }

                pcb-&gt;tos--;
            }

            /* This could be done if no AST construction would be done: */
            /* pcb-&gt;tos -= @@prefix_productions[ pcb-&gt;idx ].length; */

            if( node )
            {
                if( ( lnode = pcb-&gt;tos-&gt;node ) )
                {
                    while( lnode-&gt;next )
                        lnode = lnode-&gt;next;

                    lnode-&gt;next = node;
                    node-&gt;prev = lnode;
                }
                else
                    pcb-&gt;tos-&gt;node = node;
            }

            if( *@@prefix_productions[ pcb-&gt;idx ].emit )
            {
                if( ( node = @@prefix_ast_create( pcb,
                                @@prefix_productions[ pcb-&gt;idx ].emit,
                                    (UNICC_SCHAR*)NULL ) ) )
                {
                    node-&gt;child = pcb-&gt;tos-&gt;node;
                    pcb-&gt;tos-&gt;node = node;
                }
            }

            /* Enforced error in semantic actions? */
            if( pcb-&gt;act == UNICC_ERROR )
                break;

            /* Goal symbol reduced, and stack is empty? */
            if( pcb-&gt;lhs == @@goal &amp;&amp; pcb-&gt;tos == pcb-&gt;stack )
            {
                memcpy( &amp;( pcb-&gt;tos-&gt;value ), &amp;( pcb-&gt;ret ),
                            sizeof( @@prefix_vtype ) );
                pcb-&gt;ast = pcb-&gt;tos-&gt;node;

                UNICC_CLEARIN( pcb );

                pcb-&gt;act = UNICC_SUCCESS;

                #if UNICC_DEBUG
                fprintf( stderr, "%s: goal symbol reduced, exiting parser\n",
                        UNICC_PARSER );
                #endif
                break;
            }

            #if UNICC_DEBUG
            fprintf( @@prefix_dbg, "%s: after reduction, "
                        "shifting nonterminal %d (%s)\n",
                            UNICC_PARSER, pcb-&gt;lhs,
                                @@prefix_symbols[ pcb-&gt;lhs ].name );
            #endif

            @@prefix_get_go( pcb );

            pcb-&gt;tos++;
            pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;

            memcpy( &amp;( pcb-&gt;tos-&gt;value ), &amp;( pcb-&gt;ret ),
                        sizeof( @@prefix_vtype ) );
            pcb-&gt;tos-&gt;symbol = &amp;( @@prefix_symbols[ pcb-&gt;lhs ] );
            pcb-&gt;tos-&gt;state = ( pcb-&gt;act &amp; UNICC_REDUCE ) ? -1 : pcb-&gt;idx;
            pcb-&gt;tos-&gt;line = pcb-&gt;line;
            pcb-&gt;tos-&gt;column = pcb-&gt;column;
        }

        if( pcb-&gt;act == UNICC_SUCCESS || pcb-&gt;act == UNICC_ERROR )
            break;

        /* If in error recovery, replace old-symbol */
        if( pcb-&gt;error_delay == UNICC_ERROR_DELAY
                &amp;&amp; ( pcb-&gt;sym = pcb-&gt;old_sym ) &lt; 0 )
        {
            /* If symbol is invalid, try to find new token */
            #if UNICC_DEBUG
            fprintf( @@prefix_dbg, "%s: error recovery: "
                "old token invalid, requesting new token\n",
                        UNICC_PARSER );
            #endif

            while( !@@prefix_get_sym( pcb ) )
            {
                /* Skip one character */
                pcb-&gt;len = 1;

                UNICC_CLEARIN( pcb );
            }

            #if UNICC_DEBUG
            fprintf( @@prefix_dbg, "%s: error recovery: "
                "new token %d (%s)\n", UNICC_PARSER, pcb-&gt;sym,
                    @@prefix_symbols[ pcb-&gt;sym ].name );
            #endif
        }
        else
        {
            @@prefix_get_sym( pcb );
        }

#if UNICC_DEBUG
        fprintf( @@prefix_dbg, "%s: current token %d (%s)\n",
                    UNICC_PARSER, pcb-&gt;sym,
                        ( pcb-&gt;sym &lt; 0 ) ? "(null)" :
                            @@prefix_symbols[ pcb-&gt;sym ].name );
#endif

        /* Get action table entry */
        if( !@@prefix_get_act( pcb ) )
        {
            /* Error state, try to recover */
            if( @@prefix_handle_error( pcb,
#if UNICC_DEBUG
                    @@prefix_dbg
#else
                    (FILE*)NULL
#endif
                    ) )
                break;
        }

#if UNICC_DEBUG
        fprintf( @@prefix_dbg,
            "%s: sym = %d (%s) [len = %d] tos-&gt;state = %d act = %s idx = %d\n",
                UNICC_PARSER, pcb-&gt;sym,
                    ( ( pcb-&gt;sym &gt;= 0 ) ?
                        @@prefix_symbols[ pcb-&gt;sym ].name :
                            "(invalid symbol id)" ),
                    pcb-&gt;len, pcb-&gt;tos-&gt;state,
                        ( ( pcb-&gt;act == UNICC_SHIFT &amp; UNICC_REDUCE ) ?
                                "shift/reduce" :
                            ( pcb-&gt;act &amp; UNICC_SHIFT ) ?
                                    "shift" : "reduce" ), pcb-&gt;idx );
#if UNICC_STACKDEBUG
        @@prefix_dbg_stack( @@prefix_dbg, pcb-&gt;stack, pcb-&gt;tos );
#endif
#endif

        /* Shift */
        if( pcb-&gt;act &amp; UNICC_SHIFT )
        {
            pcb-&gt;next = pcb-&gt;buf[ pcb-&gt;len ];
            pcb-&gt;buf[ pcb-&gt;len ] = '\0';

#if UNICC_DEBUG
            fprintf( @@prefix_dbg, "%s: &gt;&gt; shifting terminal %d (%s)\n",
            UNICC_PARSER, pcb-&gt;sym, @@prefix_symbols[ pcb-&gt;sym ].name );
#endif

            if( @@prefix_alloc_stack( pcb ) &lt; 0 )
                return (@@goal-type)0;

            pcb-&gt;tos++;
            pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;

            /*
                Execute scanner actions, if existing.
                Here, UNICC_ON_SHIFT is set to 1, so that shifting-
                related operations will be performed.
            */
#define UNICC_ON_SHIFT	1
            switch( pcb-&gt;sym )
            {
@@scan_actions

                default:
                    @@top-value = @@prefix_get_input( pcb, 0 );
                    break;
            }
#undef UNICC_ON_SHIFT

            pcb-&gt;tos-&gt;state = ( pcb-&gt;act &amp; UNICC_REDUCE ) ? -1 : pcb-&gt;idx;
            pcb-&gt;tos-&gt;symbol = &amp;( @@prefix_symbols[ pcb-&gt;sym ] );
            pcb-&gt;tos-&gt;line = pcb-&gt;line;
            pcb-&gt;tos-&gt;column = pcb-&gt;column;

            if( *pcb-&gt;tos-&gt;symbol-&gt;emit )
                pcb-&gt;tos-&gt;node = @@prefix_ast_create( pcb,
                                    pcb-&gt;tos-&gt;symbol-&gt;emit,
                                        @@prefix_lexem( pcb ) );
            else
                pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;

            pcb-&gt;buf[ pcb-&gt;len ] = pcb-&gt;next;

            /* Perform the shift on input */
            if( pcb-&gt;sym != @@eof &amp;&amp; pcb-&gt;sym != @@error )
            {
                UNICC_CLEARIN( pcb );
                pcb-&gt;old_sym = -1;
            }

            if( pcb-&gt;error_delay )
                pcb-&gt;error_delay--;
        }
    }

    #if UNICC_DEBUG
    fprintf( @@prefix_dbg, "%s: parse completed with %d errors\n",
        UNICC_PARSER, pcb-&gt;error_count );
    #endif

    /* Save return value */
    ret = @@goal-value;

    /* Clean up parser control block */
    free( pcb-&gt;buf );
    free( pcb-&gt;stack );
#if UNICC_UTF8
    free( pcb-&gt;lexem );
#endif

    /* Clean memory of self-allocated parser control block */
    if( pcb-&gt;is_internal )
        free( pcb );

    return ret;
}

@@epilogue

/* Create Main? */
#if @@epilogue_len == 0
    #ifndef UNICC_MAIN
    #define UNICC_MAIN 	1
    #endif
#else
    #ifndef UNICC_MAIN
    #define UNICC_MAIN 	0
    #endif
#endif

#if UNICC_MAIN

int main( int argc, char** argv )
{
#define UNICCMAIN_SILENT		1
#define UNICCMAIN_ENDLESS		2
#define UNICCMAIN_LINEMODE		4
#define UNICCMAIN_SYNTAXTREE	8
#define UNICCMAIN_AUGSYNTAXTREE	16

    char*			opt;
    int				flags	= 0;
    int				i;
    @@prefix_pcb	pcb;

#ifdef LC_ALL
    setlocale( LC_ALL, "" );
#endif

    /* Get command-line options */
    for( i = 1; i &lt; argc; i++ )
    {
        if( *(argv[i]) == '-' )
        {
            opt = argv[i] + 1;

            /* Long option coming? */
            if( *opt == '-' )
            {
                opt++;

                if( !strcmp( opt, "silent" ) )
                    flags |= UNICCMAIN_SILENT;
                else if( !strcmp( opt, "endless" ) )
                    flags |= UNICCMAIN_ENDLESS;
                else if( !strcmp( opt, "line-mode" ) )
                    flags |= UNICCMAIN_LINEMODE;
                else
                {
                    fprintf( stderr, "Unknown option '--%s'\n", argv[i] );
                    return 1;
                }
            }

            for( ; *opt; opt++ )
            {
                if( *opt == 's' )
                    flags |= UNICCMAIN_SILENT;
                else if( *opt == 'e' )
                    flags |= UNICCMAIN_ENDLESS;
                else if( *opt == 'l' )
                    flags |= UNICCMAIN_LINEMODE;
                else
                {
                    fprintf( stderr, "Unknown option '-%c'\n", *opt );
                    return 1;
                }
            }
        }
    }

    /* Parser invocation loop */
    do
    {
        if( !( flags &amp; UNICCMAIN_SILENT ) )
            printf( "\nok\n" );

        /* Invoke parser */
        memset( &amp;pcb, 0, sizeof( @@prefix_pcb ) );

        if( flags &amp; UNICCMAIN_LINEMODE )
            pcb.eof = '\n';
        else
            pcb.eof = EOF;

        @@prefix_parse( &amp;pcb );

        /* Print AST */
        if( pcb.ast )
        {
            @@prefix_ast_print( stderr, pcb.ast );
            @@prefix_ast_free( pcb.ast );
        }
    }
    while( flags &amp; UNICCMAIN_ENDLESS );

    return 0;
}
#endif

</file>
<file filename="@@basename.h">/*
    Parser header generated by unicc from @@filename.
    DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
*/

#ifndef @@CBASENAME_H
#define @@CBASENAME_H

/* Wide character processing enabled? */
#ifndef UNICC_WCHAR
#define UNICC_WCHAR					0
#endif

/* UTF-8 processing enabled? */
#if !UNICC_WCHAR
#ifndef UNICC_UTF8
#	define UNICC_UTF8				1
#endif
#else
#	ifdef UNICC_UTF8
#	undef UNICC_UTF8
#	endif
#	define UNICC_UTF8				0
#endif

/* UNICC_CHAR is used as character type for internal processing */
#ifndef UNICC_CHAR
#if UNICC_UTF8 || UNICC_WCHAR
#	define UNICC_CHAR				wchar_t
#	define UNICC_CHAR_FORMAT		"%S"
#else
#	define UNICC_CHAR				char
#	define UNICC_CHAR_FORMAT		"%s"
#endif
#endif /* UNICC_CHAR */

/* UNICC_SCHAR defines the character type for semantic action procession */
#ifndef UNICC_SCHAR
#if UNICC_WCHAR
#	define UNICC_SCHAR				wchar_t
#	define UNICC_SCHAR_FORMAT		"%S"
#else
#	define UNICC_SCHAR				char
#	define UNICC_SCHAR_FORMAT		"%s"
#endif
#endif /* UNICC_SCHAR */

/* Boolean */
#ifndef UNICC_BOOLEAN
#define UNICC_BOOLEAN			short
#endif

/* Debug level */
#ifndef UNICC_DEBUG
#define UNICC_DEBUG				0
#endif

/* Stack debug switch */
#ifndef UNICC_STACKDEBUG
#define UNICC_STACKDEBUG		0
#endif

/* Parse error macro */
#ifndef UNICC_PARSE_ERROR
#define UNICC_PARSE_ERROR( pcb ) \
    fprintf( stderr, "line %d, column %d: syntax error on symbol %d, token '" \
        UNICC_SCHAR_FORMAT "'\n", \
    ( pcb )-&gt;line, ( pcb )-&gt;column, pcb-&gt;sym, @@prefix_lexem( pcb ) )
#endif

/* Input buffering clean-up */
#ifndef UNICC_CLEARIN
#define UNICC_CLEARIN( pcb )		@@prefix_clear_input( pcb )
#endif

/*TODO:*/
#ifndef UNICC_NO_INPUT_BUFFER
#define UNICC_NO_INPUT_BUFFER	0
#endif

/* Memory allocation step size for dynamic stack- and buffer allocation */
#ifndef UNICC_MALLOCSTEP
#define UNICC_MALLOCSTEP		128
#endif

/* Call this when running out of memory during memory allocation */
#ifndef UNICC_OUTOFMEM
#define UNICC_OUTOFMEM( pcb )	fprintf( stderr, \
                                    "Fatal error, ran out of memory\n" ), \
                                exit( 1 )
#endif

/* Static switch */
#ifndef UNICC_STATIC
#define UNICC_STATIC			static
#endif

#ifdef UNICC_PARSER
#undef UNICC_PARSER
#endif
#define UNICC_PARSER			"@@prefix" "debug"

/* Don't change next three defines below! */
#ifndef UNICC_ERROR
#define UNICC_ERROR				0
#endif
#ifndef UNICC_REDUCE
#define UNICC_REDUCE			1
#endif
#ifndef UNICC_SHIFT
#define UNICC_SHIFT				2
#endif
#ifndef UNICC_SUCCESS
#define UNICC_SUCCESS			4
#endif

/* Error delay after recovery */
#ifndef UNICC_ERROR_DELAY
#define UNICC_ERROR_DELAY		3
#endif

/* Enable/Disable terminal selection in semantic actions */
#ifndef UNICC_SEMANTIC_TERM_SEL
#define UNICC_SEMANTIC_TERM_SEL	0
#endif

/* Value Types */
@@value-type-definition

/* Typedef for symbol information table */
typedef struct
{
    char*			name;
    char*			emit;
    short			type;
    UNICC_BOOLEAN	lexem;
    UNICC_BOOLEAN	whitespace;
    UNICC_BOOLEAN	greedy;
} @@prefix_syminfo;

/* Typedef for production information table */
typedef struct
{
    char*	definition;
    char*	emit;
    int		length;
    int		lhs;
} @@prefix_prodinfo;

/* Abstract Syntax Tree */
typedef struct @@prefix_AST @@prefix_ast;

struct @@prefix_AST
{
    char*			emit;
    UNICC_SCHAR*	token;

    @@prefix_ast*	parent;
    @@prefix_ast*	child;
    @@prefix_ast*	prev;
    @@prefix_ast*	next;
};

/* Stack Token */
typedef struct
{
    @@prefix_vtype		value;
    @@prefix_ast*		node;

    @@prefix_syminfo*	symbol;

    int					state;
    unsigned int		line;
    unsigned int		column;
} @@prefix_tok;


/* Parser Control Block */
typedef struct
{
    /* Is this PCB allocated by parser? */
    char				is_internal;

    /* Stack */
    @@prefix_tok*		stack;
    @@prefix_tok*		tos;

    /* Stack size */
    unsigned int		stacksize;

    /* Values */
    @@prefix_vtype		ret;
    @@prefix_vtype		test;

    /* State */
    int					act;
    int					idx;
    int					lhs;

    /* Lookahead */
    int					sym;
    int					old_sym;
    unsigned int		len;

    /* Input buffering */
    UNICC_SCHAR*		lexem;
    UNICC_CHAR*			buf;
    UNICC_CHAR*			bufend;
    UNICC_CHAR*			bufsize;

    /* Lexical analysis */
    UNICC_CHAR			next;
    UNICC_CHAR			eof;
    UNICC_BOOLEAN		is_eof;

    /* Error handling */
    int					error_delay;
    int					error_count;

    unsigned int		line;
    unsigned int		column;

    /* Abstract Syntax Tree */
    @@prefix_ast*		ast;

    /* User-defined components */
    @@pcb

} @@prefix_pcb;

#endif /* @@CBASENAME_H */
</file>
</generator>
