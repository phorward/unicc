<?xml version="1.0" standalone="yes"?>
<!--
This template should serve as a general description and reference of how
templates for the UniCC parser generator's static build-in code generator
may be described.

It should be possible to abstract this template and given expansion macros
to several other programming languages, not only C-like ones.

In this template, there are many expansion macros used. Expansion macros begin
with "@@" and a followed identifier. These macros are expaned in several stages,
some macros represent values that directly come from the code generator, other
macros define code-parts that had already been constructed by subsequent
construction stages and are inserted in particular positions. All macros are
pre-defined by the UniCC program module generator, is is not possible to build
own expansion macros or deviating construction logics due the statical structure
of the UniCC program module generator.

The expansion macro @@prefix holds the prefix which is possibly defined for a
grammar.

No XML-tag is 'really' required. UniCC will drop a warning when it misses a tag,
but continues code generation with the tags it finds.

Some of the following comments begin with 1D TABLE or 2D TABLE. A 1D TABLE
expands into an one-dimensional array, a 2D TABLE into a two-dimensional array;
To obtain the sizes for both dimensions, there are expanding macros both in the
<file>-tag and related to every table.

1D Tables always consist of a <col> and a <col_sep> tag.
2D Tables always consist of a <row_start>, <row_end>, <row_sep>, <col> and a
<col_sep> tag. <row_sep> and <col_sep> define separators that will be inserted
between the rows/columns, except the last row/column.
-->

<generator name="C">
	<!--
	****************************************************************************
	Escape sequences
	****************************************************************************
	These are the escapable sequence definitions for the target language
	which should be replaced when terminal-/nonterminal (especially generated
	ones) names are generated into the target file, e.g. in the <symbols>-tag.
	-->

	<!-- Backslash must be double-quoted -->
	<escape-sequence for="\" do="\\" />
	<!-- Escape double quotation marks -->
	<escape-sequence for="&#x22;" do="\&#x22;" />

	<!--
	****************************************************************************
	Value-stack templates
	****************************************************************************
	-->

	<!-- Default (return) value type for nonterminals -->
	<vstack_def_type>int</vstack_def_type>
	<!-- Default value type for character-class terminals -->
	<vstack_term_type>int</vstack_term_type>

	<!--
	Code to be generated for the value stack datatype-definition
	when only one datatype is used within the whole grammar (or if
	always the default-type is used).

	Placeholders:	@@value-type			- 	Expands to the type-declaration
												of the only used value type.
	-->
	<vstack_single>typedef @@value-type @@prefix_vtype;</vstack_single>

	<!--
	Begin and end of code to be generated for the value stack
	datatype-definition when multiple datatypes are used within the
	whole grammar.  Note that you can define here even struct-like
	code or array-like structure if your target language supports
	only those.

	Placeholders:	@@number-of-value-types	-	Expands to the maximum number
												of value types possible here.
												Can be used in both of the
												following tags.
	-->
	<vstack_union_start>typedef union @@prefix_VTYPE&#x0A;{&#x0A;</vstack_union_start>
	<vstack_union_end>} @@prefix_vtype;&#x0A;&#x0A;</vstack_union_end>

	<!--
	This tag defines a data type definition within the union.
	As @@attribute, the content of the <vstack_union_att>-tag is expanded,
	which then contains a consecutive number of the datatype.
	This block is repeated for every value type within the union/whatever ;)

	Placeholders:	@@value-type			- 	Expands to the type-declaration
												of the current data type as
												specified within the grammar.
					@@attribute				-	As @@attribute, the content
												of the <vstack_union_att>-tag
												is expanded, which then
												contains a consecutive number
												of the datatype.
					@@value-type-id			-	The value type ID, which begins
												at 0. This can be the index of
												an array!
	-->
	<vstack_union_def>&#x09;@@value-type @@attribute;&#x0A;</vstack_union_def>

	<!--
	This tag defines is used in several code-generation parts, both when
	the value stack union is defined and when reduction code for productions
	is produced.

	Placeholders:	@@value-type-id			-	The value type ID, which
												begins at 0.
												This can be the index of
												an array!
	-->
	<vstack_union_att>value_@@value-type-id</vstack_union_att>

	<!--
	****************************************************************************
	Semantic action templates
	****************************************************************************
	-->

	<!--
	Begin and end of code to be generated for each reduction code action of a
	production. This code is embedded to a switch-structure below, every block
	is a "case" within this switch. <action_start> is generated BEFORE and
	<action_end> BEHIND each reduction code.

	Placeholders:	@@production-number		-	The number of the production to
												be reduced. Can be used in both
												of the following tags.
	-->
	<action_start>&#x09;&#x09;&#x09;&#x09;case @@production-number:&#x0A;&#x09;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;</action_start>
	<action_end>&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x09;&#x09;&#x09;&#x09;break;
	</action_end>

	<!--
	Single value access when only one datatype is used in the whole grammar.

	Placeholders:	@@offset				-	The number of the right-hand
												side symbol to be accessed.
												This is the number specified in
												the production reduction code
												as number or even by the
												right-hand side element's
												identifier. The offset is
												inserted here by UniCC's
												code generator.
	-->
	<action_single>( ( pcb->tos - @@offset )->value )</action_single>

	<!--
	Multiple value access, in case of different datatypes used within the
	grammar.

	Placeholders:	@@offset				-	The number of the right-hand
												side symbol to be accessed.
												This is the number specified in
												the production reduction code
												as number or even by the
												right-hand side element's
												identifier. The offset is
												inserted here by UniCC's
												code generator.
					@@attribute				-	As @@attribute, the content of
												the <vstack_union_att>-tag is
												expanded, which then contains
												a consecutive number of the
												datatype.
	-->
	<action_union>( ( pcb->tos - @@offset )->value.@@attribute )</action_union>

	<!--
	Single value left-hand side assignment variable when only one datatype
	is used in the whole grammar.

	Placeholders:	none
	-->
	<action_lhs_single>pcb->ret</action_lhs_single>

	<!--
	Multiple value left-hand side assignment variable when different
	datatypes are used within the whole grammar.

	Placeholders:	@@attribute				-	As @@attribute, the content of
												the <vstack_union_att>-tag is
												expanded, which then contains
												a consecutive number of the
												datatype.
	-->
	<action_lhs_union>pcb->ret.@@attribute</action_lhs_union>

	<!--
	This template will be triggered when a semantic action selects a
	left-hand side. By default, the primary left-hand side will be replaced
	by the production after reduction. This can be changed by using the
	@$<name>-placeholders in semantic actions.

	Only defined left-hand sides for the production can be associated.

	Placeholders:	@@sym					-	Will be replaced by the
												symbol-id of the specified
												left-hand side symbol.
	-->
	<action_set_lhs>( pcb->lhs = @@sym )</action_set_lhs>

	<!--
	****************************************************************************
	Semantic terminal action templates
	****************************************************************************
	-->

	<!--
	Begin and end of code to be generated for each match of a regular
	expression token. This code is embedded to a switch-structure below,
	every block is a "case" within this switch. <scan_action_start> is
	generated BEFORE and <scan_action_end> BEHIND each reduction code.

	The code here is only produced when the matched regex-terminal contains
	individual code segments.

	Placeholders:	@@symbol-number			-	The id of the terminal the
												lexical analyzer action belongs
												to. Can be used in both of the
												following tags.
	-->

	<scan_action_start>&#x09;&#x09;&#x09;&#x09;case @@symbol-number:&#x0A;&#x09;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;</scan_action_start>
	<scan_action_end>&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x09;&#x09;&#x09;&#x09;break;
	</scan_action_end>

	<!--
	The content of the tags <scan_action_begin_offset> and
	<scan_action_end_offset> are inserted in regex-terminal semantic code
	blocks for the placeholders @> and @< to get the start-address and
	length of the matched string. Normally, these are variable names.

	Placeholders:	none
	-->
	<scan_action_begin_offset>@@prefix_lexem( pcb )</scan_action_begin_offset>
	<scan_action_end_offset>pcb->len</scan_action_end_offset>

	<!--
	When @@ is used in regex-terminal semantic code blocks, a variable that
	receives the semantic value of the token to be pushed to the value stack
	must be given. For single value assignments,this is done here.
	This value is only used when the grammar uses only one datatype.

	Placeholders:		none
	-->
	<scan_action_ret_single>pcb->tos->value</scan_action_ret_single>

	<!--
	Same play for multiple value assignments in regex-terminal semantic action blocks.

	Placeholders:	@@attribute				-	As @@attribute, the content of
												the <vstack_union_att>-tag is
												expanded, which then contains
												a consecutive number of the
												datatype.
	-->
	<scan_action_ret_union>( pcb->tos->value.@@attribute )</scan_action_ret_union>

	<!--
	This template is used when there is a semantic action-based
	regular expression terminal decision. This is equivalent to the
	selection of left-hand side in semantic production actions above.

	Placeholders:	@@sym				-		The symbol-id of the requested
												terminal symbol will be inserted
												here.
	-->
	<scan_action_set_symbol>( pcb->sym = @@sym )</scan_action_set_symbol>

	<!--
	****************************************************************************
	Parse table templates
	****************************************************************************
	-->

	<!-- 1D TABLE
	The <defprod>-tag defines an one-dimensional array for the id's of
	the default productions that should be reduced when no other action
	is selected. UniCC choses the default production by the most common
	reduction that comes up. All reductions which belong to that production
	are removed from the action table, so that the default table is chosen.
	The following Placeholders can only be used in the <col>-tag below
	<defprod>.

	Placeholders:	@@state-number			-	The id-number of the state
												where the default production
												belongs to.
					@@production-number		-	The production id number
												indexing the production.
												This can be automatically
												solved via the array index
												itself. The production
												numbers begins at 0.
												If there is no adequate
												default-production, the
												production-number will be
												-1.
	-->
	<defprod>
		<col>@@production-number</col>
		<col_sep>, </col_sep>
	</defprod>

	<!-- 2D TABLE
	The <acttab>-tag expands to the parser action table. The action table
	describes the parser actions for every state and lookahead-symbol
	combination (resp. state-terminal combination).

	Placeholders:	@@number-of-columns		-	Total number of columns
												for every entry. Can only
												be used in <row_start> and
												<row_end>.
					@@row					-	The row index, beginning
												at 0. Can only be used in
												<row_start> and <row_end>.
					@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@symbol				-	Lookahead-symbol ID for
												each entry column, can only
												be used in <col>.
					@@action				-	The action for each entry
												column, can only be used in
												<col>. This expands to
												1 for reduce,
												2 for shift and
												3 for shift&reduce.
					@@index					-	The number of the next state
												in case of a shift, or the
												number of the reduction
												action in case of a reduce
												or shift&reduce action.
	-->
	<acttab>
		<row_start>&#x09;{ @@number-of-columns</row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>, @@symbol,@@action,@@index </col>
		<col_sep></col_sep>
	</acttab>

	<!-- 2D TABLE
	The <gotab>-tag expands to the parser goto table. The goto table
	describes the parser actions to be performed on a state and
	nonterminal-symbol combination right after a reduction.

	Placeholders:	@@number-of-columns		-	Total number of columns
												for every entry. Can only
												be used in <row_start> and
												<row_end>.
					@@row					-	The row index, beginning
												at 0. Can only be used in
												<row_start> and <row_end>.
					@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@symbol				-	Nonterminal-symbol ID for
												each entry column, can only
												be used in <col>.
					@@action				-	The action for each entry
												column, can only be used in
												<col>. This expands to
												2 for shift and
												3 for shift&reduce.

												A reduce-only will never be
												the case.
					@@index					-	The number of the next state.
	-->
	<gotab>
		<row_start>&#x09;{ @@number-of-columns</row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>, @@symbol,@@action,@@index </col>
		<col_sep></col_sep>
	</gotab>


	<!--
	****************************************************************************
	Lexical analyzer table templates
	****************************************************************************
	UniCC constructs one single lexical analyzer in insensitive mode, and
	several lexical analyzers in sensitive mode, that must be selected for every
	LALR-state.

	Several states may use the same lexical analyzer, so there is a table to
	select the lexical analyzer from, relating to every LALR-state.
	A lexical analyzer is a deterministic finite-state machine (DFA) that is
	pre-calculated by UniCC and used to identify tokens from the input,
	according to context-valid possibilities (sensitive mode) or globally
	(insensitive mode).
	-->

	<!-- 1D TABLE
	The <dfa_select>-tag expands to a table that hold the index of the lexical
	analyzer for every LALR-state.

	Placeholders:	@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@machine				-	Expand to the index of the state
												machine for the LALR-state.
												Index begins at 0.
	-->
	<dfa_select>
		<col>@@machine</col>
		<col_sep>, </col_sep>
	</dfa_select>

	<!-- 1D TABLE
	The <dfa_char>-tag expands to a table that hold all the characters for all
	states, where a character-range with @@from = -1 and @@to = -1 defines the
	end of a state character range definition.

	Placeholders:	@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@from					-	Character-code from
					@@to					-	Character-code to
	-->
	<dfa_char>
		<col>@@from, @@to</col>
		<col_sep>, </col_sep>
	</dfa_char>

	<!-- 1D TABLE
	The <dfa_trans>-tag expands to a table that hold all the transitions
	to the next DFA state if a character range from <dfa_char> matches.

	Placeholders:	@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@goto					-	Next state to go to.
	-->
	<dfa_trans>
		<col>@@goto</col>
		<col_sep>, </col_sep>
	</dfa_trans>


	<!-- 2D TABLE
	The <dfa_idx>-tag expands to a table that hold for every lexical analyzer
	DFA a table with the offsets of the character-ranges in table <dfa_char>.

	Placeholders:	@@row					-	The row index, beginning
												at 0. Can only be used in
												<row_start> and <row_end>.
					@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@index					-	Beginning offset of the state,
												must be multiplied by 2 to
												get the correct index in most
												cases.
					@@number-of-columns		-	Number of DFA states for the
												given DFA state machine.
	-->
	<dfa_idx>
		<row_start>&#x09;{ </row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@index * 2</col>
		<col_sep>, </col_sep>
	</dfa_idx>

	<!-- 2D TABLE
	The <dfa_accept>-tag expands to a table that hold accepting symbol
	identifier tables for every DFA state.

	Placeholders:	@@row					-	The row index, beginning
												at 0. Can only be used in
												<row_start> and <row_end>.
					@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@accept				-	Accepting ID of the terminal
												symbol that is probably
												matched until this state by
												the lexical analyzer.
					@@number-of-columns		-	Number of DFA states for the
												given DFA state machine.
	-->
	<dfa_accept>
		<row_start>&#x09;{ </row_start>
		<row_end> }</row_end>
		<row_sep>,&#x0A;</row_sep>
		<col>@@accept</col>
		<col_sep>, </col_sep>
	</dfa_accept>

	<!--
	****************************************************************************
	Symbol and production information tables
	****************************************************************************
	-->

	<!-- 1D TABLE
	The <symbol>-tag expands to a symbol information table that has an
	entry for each grammar symbol (intermixed terminal and nonterminal),
	which may contain its definition string or name, its type, its data-type
	index and several symbol-related flags. The table is not required for
	the parsing, but used for debug/trace and extended possibilites, e.g.
	automatically generated syntax trees.

	Placeholders:	@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@greedy				- 	1, if the symbol is a regular
												expression terminal and should
												be parsed greedy, 0 if not.
					@@lexem					-	1, if the symbol is configured
												as a lexem, 0 if not.
					@@symbol				-	The ID of the symbol.
					@@symbol-name			-	The symbol string of the symbol,
												which is escaped by the escape
												sequences defined on top.
					@@type					-	The symbol type:
												0) Nonterminal
												1) Character-class terminal
												2) Regex-class terminal
												3) String-class terminal
					@@whitespace			-	1, if the symbol is configured
												as whitespace symbol, 0 if not.
	-->
	<symbols>
		<col>	{ /* @@symbol */ "@@symbol-name", "@@emit", @@type, @@lexem, @@whitespace, @@greedy }</col>
		<col_sep>,&#x0A;</col_sep>
	</symbols>

	<!-- 1D TABLE
	The <production>-tag expands to a production information table that has an
	entry for every production, which may contain its definition string, length
	and default left-hand side. This table is not required for the parsing, but
	used for debug/trace and extended possibilites, e.g. automatically
	generated syntax trees.

	Placeholders:	@@column				-	The column index, beginning
												at 0. Can only be used in
												<col>.
					@@production-number		-	The ID of the production.
					@@production			-	The production string,
												which is escaped by the escape
												sequences defined on top.
					@@length				-	The length of the production
												(symbols on the right-hand
												side)
					@@lhs					-	Default left-hand side.
												Multiple left-hand sides are
												not covered here.
	-->
	<productions>
		<col>	{ /* @@production-number */ "@@production", "@@emit", @@length, @@lhs }</col>
		<col_sep>,&#x0A;</col_sep>
	</productions>

	<!--
	The <code_localization>-tag is printed before every line of semantic
	code, and equipped with some information about the source. Programming
	languages like C support a way to let the compiler report other locations
	in generated files, like it is the case with UniCC.

	Placeholders:	@@line					-	The first line number where the
												semantic code was parsed at.
					@@filename				-	The filename, where the semantoc
												code has been parsed from (this
												is the name of the parser
												definition file)
	-->
	<code_localization>#line @@line "@@filename"
</code_localization>


	<!--
	Now, the output files are described. It can be one file or multiple, all
	allow the insertion of the same placeholers.

	Placeholders:	@@actions				-	Inserts the parser action code
												that is constructed from the
												program code attached to
												productions in combination with
												the tags
												<action_start> and <action_end>
					@@action-table			-	Inserts the expanded action
												table that is generated from the
												<acttab> tags.
					@@basename				-	The basename of the target file.
					@@Cbasename				-	The basename of the target file,
												as C-identifier. For example,
												"test.1" becomes "test_1".
					@@CBASENAME				-	The basename of the target file,
												as C-identifier, in upper case
												order. For example,
												"test.1" becomes "TEST_1".
					@@character-universe		-	Upper limit of the character
												universe. Lowest limit is
												always 0.
					@@copyright_len			-	The length of the content of
												the #copyright parser directive.
					@@copyright				-	Content of the #copyright
												parser directive.
					@@deepest-action-row		-	Number of elements in the
												deepest row of the expanded
												array of the <acttab>-tag.
												This should be used for array
												memory allocation.
					@@deepest-dfa-accept-row-	Number of elements in the
												deepest row of the expanded
												array of the <dfa_accept>-tag.
												This is used for array memory
												allocation.
					@@deepest-dfa-index-row	-	Number of elements in the
												deepest row of the expanded
												array of the <dfa_idx>-tag.
												This is used for array memory
												allocation.
					@@deepest-goto-row		-	Number of elements in the
												deepest row of the expanded
												array of the <gotab>-tag.
												This should be used for array
												memory allocation.
					@@default-productions	-	Expands to the array of
												default productions from the
												<defprod>-tag.
					@@description_len		-	The length of the content of
												the #description parser
												directive.
					@@description			-	Content of the #description
												parser directive.
					@@dfa-accept			-	Expands to the array of
												DFA accepting states from the
												<dfa_accept>-tag.
					@@dfa-char				-	Expands to the array of DFA
												state characters from the
												<dfa_char>-tag.
					@@dfa-index				-	Expands to the array of
												DFA state indexes from the
												<dfa_idx>-tag.
					@@dfa-select				-	Expands to the array of
												DFA machine selection from the
												<dfa_select>-tag.
					@@dfa-trans				-	Expands to the array of
												DFA transitions from the
												<dfa_trans>-tag.
					@@eof					-	The symbol ID of the end-of-file
												terminal symbol. This is -1
												if not defined.
					@@epilogue_len			-	The length of the content of
												the #epilogue parser
												directive.
					@@epilogue				-	Content of the #epilogue
												parser directive.
					@@error					-	The symbol ID of the error
												resynchrinoization terminal
												This is -1 if not defined.
					@@filename_len			-	The length of the parser source
												filename.
					@@filename				-	The filename of the parser
												source file.
					@@goal					-	The symbol ID of the goal
												symbol (always a nonterminal).
					@@goal-production		-	The production ID of the
												goal production.
					@@goto-table			-	Inserts the expanded goto table
												that is generated from the
												<gotab> tags.
					@@max-symbol-name-length-	Maxiumum size of the longest
												symbol name that was generated
												in the <symbols>-tag.
					@@mode					-	The parser construction mode;
												0 for senstivie mode,
												1 for insensitive mode

					@@name_len				-	The length of the content of
												the #parser parser
												directive.
					@@name					-	Content of the #parser
												parser directive.
					@@number-of-dfa-machines-	Total number of DFA state
												machines. This is always 1
												in insentivie parsers.
					@@number-of-productions	-	The number of productions.
					@@number-of-states		-	The number of LALR(1) states.
					@@number-of-symbols		-	The number of symbols.
					@@pcb_len				-	The length of the content of
												the #pcb parser directive.
					@@pcb					-	Content of the #pcb
												parser directive.
					@@productions			-	Expands to the productions
												string array produced by
												the <productions>-tag.
					@@prologue_len			-	The length of the content of
												the #prologue parser
												directive.
					@@prologue				-	Content of the #prologue
												parser directive.
					@@scan_actions			-	Expands to the semantic
												scanner actions that may
												be processed when a token
												has been correctly matched.
					@@size-of-dfa-characters-	The size of the array
												expaned by <dfa_char>.
					@@symbols				-	Expands to the symbol
												string array produced by
												the <symbols>-tag.
					@@top-value				-	Expands to the variable
												pointing to the top of
												the value-stack.
					@@value-type-definition	-	Expands to the value type
												definitions.
					@@version_len			-	The length of the content of
												the #version parser
												directive.
					@@version				-	Content of the #version
												parser directive.

	The expansion macros @@basename, @@Cbasename, @@CBASENAME, @@filename,
	@@filename_len and @@prefix can be used everywhere in all tags. They are
	replaced as last. They can also be used in semantic actions defined in the
	parser's semantic actions. It is also possible to use the above macros in
	the filename-attribute of the file-tag, to generate adequate filenames.
	-->
	<file filename="@@basename.c">/*
	Parser module generated by unicc from @@filename.
	DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
*/

#if @@prologue_len == 0
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;locale.h&gt;
#else
@@prologue
#endif

/* Include parser control block definitions */
#include "@@basename.h"

/* Action Table */
UNICC_STATIC int @@prefix_act[ @@number-of-states ][ @@deepest-action-row * 3 + 1 ] =
{
@@action-table
};

/* GoTo Table */
UNICC_STATIC int @@prefix_go[ @@number-of-states ][ @@deepest-goto-row * 3 + 1 ] =
{
@@goto-table
};

/* Default productions per state */
UNICC_STATIC int @@prefix_def_prod[ @@number-of-states ] =
{
	@@default-productions
};

#if !@@mode
/* DFA selection table */
UNICC_STATIC int @@prefix_dfa_select[ @@number-of-states ] =
{
	@@dfa-select
};
#endif

#if @@number-of-dfa-machines
/* DFA index table */
UNICC_STATIC int @@prefix_dfa_idx[ @@number-of-dfa-machines ][ @@deepest-dfa-index-row ] =
{
@@dfa-index
};

/* DFA transition chars */
UNICC_STATIC int @@prefix_dfa_chars[ @@size-of-dfa-characters * 2 ] =
{
	@@dfa-char
};

/* DFA transitions */
UNICC_STATIC int @@prefix_dfa_trans[ @@size-of-dfa-characters ] =
{
	@@dfa-trans
};

/* DFA acception states */
UNICC_STATIC int @@prefix_dfa_accept[ @@number-of-dfa-machines ][ @@deepest-dfa-accept-row ] =
{
@@dfa-accept
};

#endif

/* Symbol information table */
UNICC_STATIC @@prefix_syminfo @@prefix_symbols[] =
{
@@symbols
};

/* Production information table */
UNICC_STATIC @@prefix_prodinfo @@prefix_productions[] =
{
@@productions
};

UNICC_STATIC UNICC_SCHAR* @@prefix_lexem( @@prefix_pcb* pcb )
{
#if UNICC_WCHAR || !UNICC_UTF8
	pcb-&gt;lexem = pcb-&gt;buf;
#else
	size_t		size;

	size = wcstombs( (char*)NULL, pcb-&gt;buf, 0 );

	if( pcb-&gt;lexem )
		free( pcb-&gt;lexem );

	if( !( pcb-&gt;lexem = (UNICC_SCHAR*)malloc(
			( size + 1 ) * sizeof( UNICC_SCHAR ) ) ) )
	{
		UNICC_OUTOFMEM( pcb );
		return (UNICC_SCHAR*)NULL;
	}

	wcstombs( pcb-&gt;lexem, pcb-&gt;buf, size + 1 );
#endif

#if UNICC_DEBUG	&gt; 2
	fprintf( stderr, "%s: lexem: pcb-&gt;lexem = &gt;" UNICC_SCHAR_FORMAT "&lt;\n",
						UNICC_PARSER, pcb-&gt;lexem );
#endif
	return pcb-&gt;lexem;
}

UNICC_STATIC @@prefix_ast* @@prefix_ast_free( @@prefix_ast* node )
{
	if( !node )
		return (@@prefix_ast*)NULL;

	@@prefix_ast_free( node-&gt;child );
	@@prefix_ast_free( node-&gt;next );

	if( node-&gt;token )
		free( node-&gt;token );

	free( node );
	return (@@prefix_ast*)NULL;
}

UNICC_STATIC @@prefix_ast* @@prefix_ast_create( @@prefix_pcb* pcb, char* emit,
													UNICC_SCHAR* token )
{
	@@prefix_ast*	node;

	if( !( node = (@@prefix_ast*)malloc( sizeof( @@prefix_ast ) ) ) )
	{
		UNICC_OUTOFMEM( pcb );
		return node;
	}

	memset( node, 0, sizeof( @@prefix_ast ) );

	node-&gt;emit = emit;

	if( token )
	{
		#if !UNICC_WCHAR
		if( !( node-&gt;token = strdup( token ) ) )
		{
			UNICC_OUTOFMEM( pcb );
			free( node );
			return (@@prefix_ast*)NULL;
		}
		#else
		if( !( node-&gt;token = wcsdup( token ) ) )
		{
			UNICC_OUTOFMEM( pcb );
			free( node );
			return (@@prefix_ast*)NULL;
		}
		#endif
	}

	return node;
}

UNICC_STATIC void @@prefix_ast_print( FILE* stream, @@prefix_ast* node )
{
	int 		i;
	static int 	rec;

	if( !node )
		return;

	if( !stream )
		stream = stderr;

	while( node )
	{
		for( i = 0; i &lt; rec; i++ )
			fprintf( stream,  " " );

		fprintf( stream, "%s", node-&gt;emit );

		if( node-&gt;token &amp;&amp; strcmp( node-&gt;emit, node-&gt;token ) != 0 )
			fprintf( stream, " (%s)", node-&gt;token );

		fprintf( stream, "\n" );

		rec++;
		@@prefix_ast_print( stream, node-&gt;child );
		rec--;

		node = node-&gt;next;
	}
}

UNICC_STATIC int @@prefix_get_act( @@prefix_pcb* pcb )
{
	int i;

	for( i = 1; i &lt; @@prefix_act[ pcb-&gt;tos-&gt;state ][0] * 3; i += 3 )
	{
		if( @@prefix_act[ pcb-&gt;tos-&gt;state ][i] == pcb-&gt;sym )
		{
			if( ( pcb-&gt;act = @@prefix_act[ pcb-&gt;tos-&gt;state ][i+1] )
					== UNICC_ERROR )
				return 0; /* Force parse error! */

			pcb-&gt;idx = @@prefix_act[ pcb-&gt;tos-&gt;state ][i+2];
			return 1;
		}
	}
	
	/* Default production */
	if( ( pcb-&gt;idx = @@prefix_def_prod[ pcb-&gt;tos-&gt;state ] ) &gt; -1 )
	{
		pcb-&gt;act = 1; /* Reduce */
		return 1;
	}

	return 0;
}

UNICC_STATIC int @@prefix_get_go( @@prefix_pcb* pcb )
{
	int i;

	for( i = 1; i &lt; @@prefix_go[ pcb-&gt;tos-&gt;state ][0] * 3; i += 3 )
	{
		if( @@prefix_go[ pcb-&gt;tos-&gt;state ][i] == pcb-&gt;lhs )
		{
			pcb-&gt;act = @@prefix_go[ pcb-&gt;tos-&gt;state ][ i + 1 ];
			pcb-&gt;idx = @@prefix_go[ pcb-&gt;tos-&gt;state ][ i + 2 ];
			return 1;
		}
	}

	return 0;
}

UNICC_STATIC int @@prefix_alloc_stack( @@prefix_pcb* pcb )
{
	unsigned int	size;

	if( !pcb-&gt;stacksize )
	{
		if( !( pcb-&gt;tos = pcb-&gt;stack = (@@prefix_tok*)malloc(
				UNICC_MALLOCSTEP * sizeof( @@prefix_tok ) ) ) )
		{
			UNICC_OUTOFMEM( pcb );
			return -1;
		}

		pcb-&gt;stacksize = UNICC_MALLOCSTEP;
	}
	else if( ( size = (unsigned int)( pcb-&gt;tos - pcb-&gt;stack ) )
				== pcb-&gt;stacksize )
	{
		@@prefix_tok*	ptr;

		if( !( ptr = (@@prefix_tok*)realloc( pcb-&gt;stack,
				( pcb-&gt;stacksize + UNICC_MALLOCSTEP )
					* sizeof( @@prefix_tok ) ) ) )
		{
			UNICC_OUTOFMEM( pcb );

			if( pcb-&gt;stack )
				free( pcb-&gt;stack );

			return -1;
		}

		pcb-&gt;tos = pcb-&gt;stack = ptr;

		pcb-&gt;stacksize += UNICC_MALLOCSTEP;
		pcb-&gt;tos += size;
	}

	return 0;
}

#ifndef UNICC_GETINPUT

#if UNICC_UTF8
static int offsets_utf8[ 6 ] =
{
    0x00000000UL, 0x00003080UL, 0x000E2080UL,
    0x03C82080UL, 0xFA082080UL, 0x82082080UL
};

static int trailbyte_utf8[ 256 ] =
{
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
};

UNICC_STATIC UNICC_CHAR @@prefix_utf8_getchar( int (*getfn)() )
{
	UNICC_CHAR	ch	= 0;
	int 		nb;
	int			c;
	
	if( !getfn )
		getfn = getchar;

	switch( ( nb = trailbyte_utf8[ ( c = (*getfn)() ) ] ) )
	{
        case 3:
			ch += c;
			ch &lt;&lt;= 6;
			c = (*getfn)();
        case 2:
			ch += c;
			ch &lt;&lt;= 6;
			c = (*getfn)();
        case 1:
			ch += c;
			ch &lt;&lt;= 6;
			c = (*getfn)();
        case 0:
			ch += c;
			break;
	}
	
	ch -= offsets_utf8[ nb ];
#if UNICC_DEBUG	&gt; 3
	fprintf( stderr, "%s: getchar: %d\n", UNICC_PARSER, ch );
#endif
	return ch;
}
#define UNICC_GETINPUT		@@prefix_utf8_getchar( getchar )

#else
#define UNICC_GETINPUT		getchar()
#endif

#endif

UNICC_STATIC UNICC_CHAR @@prefix_get_input( @@prefix_pcb* pcb, unsigned int offset )
{
#if UNICC_DEBUG	&gt; 2
	fprintf( stderr, "%s: get input: pcb-&gt;buf + offset = %p pcb-&gt;bufend = %p\n",
				UNICC_PARSER, pcb-&gt;buf + offset, pcb-&gt;bufend );
#endif

	while( pcb-&gt;buf + offset &gt;= pcb-&gt;bufend )
	{
#if UNICC_DEBUG	&gt; 2
			fprintf( stderr, "%s: get input: requiring more input\n",
					UNICC_PARSER );
#endif
		if( !pcb-&gt;buf )
		{
			pcb-&gt;bufend = pcb-&gt;buf = (UNICC_CHAR*)malloc(
				( UNICC_MALLOCSTEP + 1 ) * sizeof( UNICC_CHAR ) );

			if( !pcb-&gt;buf )
			{
				UNICC_OUTOFMEM( pcb );
				return 0;
			}

			*pcb-&gt;buf = 0;
		}
		else if( *pcb-&gt;buf &amp;&amp; !( ( pcb-&gt;bufend - pcb-&gt;buf ) %
					UNICC_MALLOCSTEP ) )
		{
			unsigned int 	size	= (unsigned int)( pcb-&gt;bufend - pcb-&gt;buf );
			UNICC_CHAR*		buf;

			if( !( buf = (UNICC_CHAR*)realloc( pcb-&gt;buf,
						( size + UNICC_MALLOCSTEP + 1 )
							* sizeof( UNICC_CHAR ) ) ) )
			{
				UNICC_OUTOFMEM( pcb );
				free( pcb-&gt;buf );

				return 0;
			}

			pcb-&gt;buf = buf;
			pcb-&gt;bufend = pcb-&gt;buf + size;
		}

		if( pcb-&gt;is_eof || ( *( pcb-&gt;bufend ) = (UNICC_CHAR)UNICC_GETINPUT )
									== pcb-&gt;eof )
		{
#if UNICC_DEBUG	&gt; 2
			fprintf( stderr, "%s: get input: can't get more input, "
						"end-of-file reached\n", UNICC_PARSER );
#endif
			pcb-&gt;is_eof = 1;
			return pcb-&gt;eof;
		}
#if UNICC_DEBUG	&gt; 2
		fprintf( stderr, "%s: get input: read char &gt;%c&lt; %d\n",
					UNICC_PARSER, (char)*( pcb-&gt;bufend ), *( pcb-&gt;bufend ) );
#endif

#if UNICC_DEBUG	&gt; 2
		fprintf( stderr, "%s: get input: reading character &gt;%c&lt; %d\n",
					UNICC_PARSER, (char)*( pcb-&gt;bufend ), *( pcb-&gt;bufend ) );
#endif

		*( ++pcb-&gt;bufend ) = 0;
	}

#if UNICC_DEBUG	&gt; 2
	{
		UNICC_CHAR*		chptr;

		fprintf( stderr, "%s: get input: offset = %d\n",
					UNICC_PARSER, offset );
		fprintf( stderr, "%s: get input: buf = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
					UNICC_PARSER, pcb-&gt;buf );
		fprintf( stderr, "%s: get input: returning %d\n",
					UNICC_PARSER, *( pcb-&gt;buf + offset ) );
	}
#endif

	return pcb-&gt;buf[ offset ];
}

UNICC_STATIC void @@prefix_clear_input( @@prefix_pcb* pcb )
{
	int		i;

	if( pcb-&gt;buf )
	{
		if( pcb-&gt;len )
		{
			/* Update counters for line and column */
			for( i = 0; i &lt; pcb-&gt;len; i++ )
			{
				if( (char)pcb-&gt;buf[i] == '\n' )
				{
					pcb-&gt;line++;
					pcb-&gt;column = 1;
				}
				else
					pcb-&gt;column++;
			}

#if UNICC_DEBUG &gt; 2
	fprintf( stderr, "%s: clear input: "
		"Clearing %d characters (%d bytes)\n",
			UNICC_PARSER, pcb-&gt;len, pcb-&gt;len * sizeof( UNICC_CHAR ) );
	fprintf( stderr, "%s: clear input: buf = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
			UNICC_PARSER, pcb-&gt;buf, sizeof( UNICC_CHAR ) );
	fprintf( stderr, "%s: clear input: pcb-&gt;bufend &gt;" UNICC_CHAR_FORMAT "&lt;\n",
			UNICC_PARSER, pcb-&gt;bufend );
#endif

			memmove( pcb-&gt;buf, pcb-&gt;buf + pcb-&gt;len,
						( ( pcb-&gt;bufend - ( pcb-&gt;buf + pcb-&gt;len ) ) + 1 + 1 )
							* sizeof( UNICC_CHAR ) );
			pcb-&gt;bufend = pcb-&gt;buf + ( pcb-&gt;bufend - ( pcb-&gt;buf + pcb-&gt;len ) );

#if UNICC_DEBUG	&gt; 2
	fprintf( stderr, "%s: clear input: now buf = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
				UNICC_PARSER, pcb-&gt;buf, sizeof( UNICC_CHAR ) );
	fprintf( stderr, "%s: clear input: now bufend = &gt;" UNICC_CHAR_FORMAT "&lt;\n",
				UNICC_PARSER, pcb-&gt;bufend, sizeof( UNICC_CHAR ) );
#endif
		}
		else
		{
			pcb-&gt;bufend = pcb-&gt;buf;
			*( pcb-&gt;buf ) = 0;
		}
	}
	
	pcb-&gt;len = 0;
	pcb-&gt;sym = -1;
#if UNICC_DEBUG	&gt; 2
	fprintf( stderr, "%s: clear input: symbol cleared\n", UNICC_PARSER );
#endif
}

#if @@number-of-dfa-machines
UNICC_STATIC void @@prefix_lex( @@prefix_pcb* pcb )
{
	int 			dfa_st	= 0;
	unsigned int	len		= 0;
	int				chr;
	UNICC_CHAR		next;
#if !@@mode
	int				mach	= @@prefix_dfa_select[ pcb-&gt;tos-&gt;state ];
#else
	int				mach	= 0;
#endif

	next = @@prefix_get_input( pcb, len );
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: next = %d\n", UNICC_PARSER, next );
#endif
	
	if( next == pcb-&gt;eof )
	{
		pcb-&gt;sym = @@eof;
		return;
	}

	do
	{
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: next = %d\n", UNICC_PARSER, next );
#endif

		chr = @@prefix_dfa_idx[ mach ][ dfa_st ];
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: chr = %d\n", UNICC_PARSER, chr );
#endif

		dfa_st = -1;
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: FIRST next = %d @@prefix_dfa_chars[ chr ] = %d, "
			"@@prefix_dfa_chars[ chr+1 ] = %d\n", UNICC_PARSER, next,
				@@prefix_dfa_chars[ chr ], @@prefix_dfa_chars[ chr + 1 ] );
#endif
		while( @@prefix_dfa_chars[ chr ] &gt; -1 )
		{
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: next = %d @@prefix_dfa_chars[ chr ] = %d, "
		"@@prefix_dfa_chars[ chr+1 ] = %d\n", UNICC_PARSER, next,
			@@prefix_dfa_chars[ chr ], @@prefix_dfa_chars[ chr + 1 ] );
#endif
			if( next &gt;= @@prefix_dfa_chars[ chr ] &amp;&amp;
				next &lt;= @@prefix_dfa_chars[ chr+1 ] )
			{
				dfa_st = *( @@prefix_dfa_trans + ( chr / 2 ) );
#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: dfa_st = %d\n", UNICC_PARSER, dfa_st );
#endif
				if( @@prefix_dfa_accept[ mach ][ dfa_st ] &gt; 0 )
				{
					pcb-&gt;len = len + 1;
					pcb-&gt;sym = @@prefix_dfa_accept[ mach ][ dfa_st ] - 1;

#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: new accepting symbol pcb-&gt;sym = %d greedy = %d\n",
			UNICC_PARSER, pcb-&gt;sym, @@prefix_symbols[ pcb-&gt;sym ].greedy );
#endif
					if( pcb-&gt;sym == @@eof )
					{
						dfa_st = -1; /* test! */
						break;
					}

					/* Stop if matched symbol should be parsed nongreedy */
					if( !@@prefix_symbols[ pcb-&gt;sym ].greedy )
					{
						dfa_st = -1;
						break;
					}
				}

				next = @@prefix_get_input( pcb, ++len );
				break;
			}

			chr += 2;
		}
	}
	while( dfa_st &gt; -1 &amp;&amp; next != pcb-&gt;eof );
	
	if( pcb-&gt;sym &gt; -1 )
	{
#if UNICC_SEMANTIC_TERM_SEL
		/*
			Execute scanner actions, if existing, but with
			UNICC_ON_SHIFT = 0, so that no memory allocation 
			should be performed. This actions should only be
			handled if there are semantic-code dependent
			terminal symbol selections.

			tos is incremented here, if the semantic code
			stores data for the symbol. It won't get lost
			in case of a shift.
		*/
		@@prefix_alloc_stack( pcb );
		pcb-&gt;tos++;

		next = pcb-&gt;buf[ pcb-&gt;len ];
		pcb-&gt;buf[ pcb-&gt;len ] = '\0';
		
#define UNICC_ON_SHIFT 	0
		switch( pcb-&gt;sym )
		{
@@scan_actions

			default:
				break;
		}
#undef UNICC_ON_SHIFT

		pcb-&gt;buf[ pcb-&gt;len ] = next;

		pcb-&gt;tos--;
#endif /* UNICC_SEMANTIC_TERM_SEL */
	}

#if UNICC_DEBUG	&gt; 1
fprintf( stderr, "%s: lex: function exits, pcb-&gt;sym = %d, pcb-&gt;len = %d\n",
			UNICC_PARSER, pcb-&gt;sym, pcb-&gt;len );
#endif
}
#endif

UNICC_STATIC int @@prefix_get_sym( @@prefix_pcb* pcb )
{
	pcb-&gt;sym = -1;
	pcb-&gt;len = 0;

#if @@mode
	do
	{
#endif
#if !@@mode

#if UNICC_DEBUG &gt; 2
		fprintf( stderr, "%s: get sym: state = %d dfa_select = %d\n",
					UNICC_PARSER, pcb-&gt;tos-&gt;state,
						@@prefix_dfa_select[ pcb-&gt;tos-&gt;state ] );
#endif

		if( @@prefix_dfa_select[ pcb-&gt;tos-&gt;state ] &gt; -1 )
			@@prefix_lex( pcb );
		/* 
		 * If there is no DFA state machine,
		 * try to identify the end-of-file symbol.
		 * If this also fails, a parse error will
		 * raise.
		 */
		else if( @@prefix_get_input( pcb, 0 ) == pcb-&gt;eof )
			pcb-&gt;sym = @@eof;
#else
		@@prefix_lex( pcb );
#endif /* !@@mode */

#if @@mode

		if( pcb-&gt;sym &gt; -1 &amp;&amp; @@prefix_symbols[ pcb-&gt;sym ].whitespace )
		{
			UNICC_CLEARIN( pcb );
			continue;
		}
		
		break;
	}
	while( 1 );
#endif /* @@mode */

	return ( pcb-&gt;sym &gt; -1 ) ? 1 : 0;
}

#if UNICC_STACKDEBUG
UNICC_STATIC void @@prefix_dbg_stack( FILE* out,
	@@prefix_tok* stack, @@prefix_tok* tos )
{
	fprintf( out, "%s: Stack Dump: ", UNICC_PARSER );

	for( ; stack &lt;= tos; stack++ )
	{
		fprintf( out, "%d%s%s%s ", stack-&gt;state,
			stack-&gt;symbol ? " (" : "",
			stack-&gt;symbol ? stack-&gt;symbol-&gt;name : "",
			stack-&gt;symbol ? ")" : "" );
	}
	
	fprintf( out, "\n" );
}
#endif /* UNICC_STACKDEBUG */

UNICC_STATIC int @@prefix_handle_error( @@prefix_pcb* pcb, FILE* @@prefix_dbg )
{
#if UNICC_DEBUG
	int					i;
#endif

	if( !pcb-&gt;error_delay )
	{
#if UNICC_DEBUG
		fprintf( @@prefix_dbg, "%s: !!!PARSE ERROR!!!\n"
				"%s: error recovery: current token %d (%s)\n",
					UNICC_PARSER, UNICC_PARSER, pcb-&gt;sym,
						( ( pcb-&gt;sym &gt;= 0 ) ?
							@@prefix_symbols[ pcb-&gt;sym ].name :
								"(null)" ) );

		fprintf( @@prefix_dbg,
				"%s: error recovery: expecting ", UNICC_PARSER );
				
		for( i = 1; i &lt; @@prefix_act[ pcb-&gt;tos-&gt;state ][0] * 3; i += 3 )
		{
			fprintf( @@prefix_dbg, "%d (%s)%s",
				@@prefix_act[ pcb-&gt;tos-&gt;state ][i],
				@@prefix_symbols[ @@prefix_act[ pcb-&gt;tos-&gt;state ][i] ].name,
				( i == @@prefix_act[ pcb-&gt;tos-&gt;state ][0] * 3 - 3 ) ?
						"\n" : ", " );
		}
		
		fprintf( @@prefix_dbg, "\n%s: error recovery: error_delay is %d, %s\n",
					UNICC_PARSER, pcb-&gt;error_delay,
					( pcb-&gt;error_delay ? "error recovery runs silently" :
						"error is reported before its recover!" ) );
#endif
	}

#if @@error &lt; 0
	/* No error token defined? Then exit here... */

#if UNICC_DEBUG
	fprintf( @@prefix_dbg,
		"%s: error recovery: No error resync token used by grammar, "
			"exiting parser.\n", UNICC_PARSER );
#endif

	UNICC_PARSE_ERROR( pcb );
	pcb-&gt;error_count++;

	return 1;
#else
	/*
	@@prefix_pcb 		org_pcb;
	*/

#if UNICC_DEBUG
	fprintf( @@prefix_dbg, "%s: error recovery: "
		"trying to recover...\n", UNICC_PARSER );
#if UNICC_STACKDEBUG
	@@prefix_dbg_stack( @@prefix_dbg, pcb-&gt;stack, pcb-&gt;tos );
#endif
#endif

	#if 0
	/* Create a copy of original parser control block (maybe later...) */
	memcpy( &amp;org_pcb, pcb, sizeof( @@prefix_pcb ) );
	org_pcb.buf = (char*)malloc( ( strlen( pcb-&gt;buf ) / UNICC_MALLOCSTEP +
					( !( strlen( pcb-&gt;buf ) % UNICC_MALLOCSTEP ) ? 1 : 0 ) )
							* UNICC_MALLOCSTEP );
	strcpy( org_pcb.buf, pcb-&gt;buf );
	#endif

	/* Remember previous symbol, or discard it */
	if( pcb-&gt;error_delay != UNICC_ERROR_DELAY )
		pcb-&gt;old_sym = pcb-&gt;sym;
	else
	{
		pcb-&gt;old_sym = -1;
		pcb-&gt;len = 1;
		UNICC_CLEARIN( pcb );
	}

	/* Try to shift on error resync */
	pcb-&gt;sym = @@error;

	while( pcb-&gt;tos &gt;= pcb-&gt;stack )
	{
#if UNICC_DEBUG
		fprintf( @@prefix_dbg, "%s: error recovery: in state %d, trying "
				"to shift error resync token...\n",
					UNICC_PARSER, pcb-&gt;tos-&gt;state );
#if UNICC_STACKDEBUG
		@@prefix_dbg_stack( @@prefix_dbg, pcb-&gt;stack, pcb-&gt;tos );
#endif
#endif
		if( @@prefix_get_act( pcb ) )
		{
			/* Shift */
			if( pcb-&gt;act &amp; UNICC_SHIFT )
			{
#if UNICC_DEBUG
				fprintf( @@prefix_dbg, "%s: error recovery: "
							"error resync shifted\n", UNICC_PARSER );
#endif
				break;
			}
		}
		
#if UNICC_DEBUG
		fprintf( @@prefix_dbg, "%s: error recovery: failed, "
					"discarding token '%s'\n", UNICC_PARSER,
						pcb-&gt;tos-&gt;symbol ?
							pcb-&gt;tos-&gt;symbol-&gt;name : "NULL" );
#endif

		/* Discard one token from stack */
		/* TODO: Discarded token memory (semantic action) */
		pcb-&gt;tos--;
	}

	if( pcb-&gt;tos &lt;= pcb-&gt;stack )
	{
#if UNICC_DEBUG
	fprintf( @@prefix_dbg, "%s: error recovery: "
				"Can't recover this issue, stack is empty.\n",
					UNICC_PARSER );	
#endif
		UNICC_PARSE_ERROR( pcb );
		pcb-&gt;error_count++;

		return 1;
	}
	
#if UNICC_DEBUG
	fprintf( @@prefix_dbg, "%s: error recovery: "
				"trying to continue with modified parser state\n",
					UNICC_PARSER );	
#endif

	pcb-&gt;error_delay = UNICC_ERROR_DELAY + 1;

	return 0;

#endif /* @@error &gt;= 0 */
}

@@goal-type @@prefix_parse( @@prefix_pcb* pcb )
{
	@@goal-type			ret;
	int					i;

	@@prefix_ast*		node;
	@@prefix_ast*		lnode;

#if UNICC_DEBUG
	@@prefix_vtype*		vptr;
	FILE* 				@@prefix_dbg;

	@@prefix_dbg = stderr;
#endif

	/* If there is no Parser Control Block given, allocate your own one! */
	if( !pcb )
	{
		if( !( pcb = (@@prefix_pcb*)malloc( sizeof( @@prefix_pcb ) ) ) )
		{
			/* Can't allocate memory */
			UNICC_OUTOFMEM( pcb );
			return (@@goal-type)0;
		}

		memset( pcb, 0, sizeof( @@prefix_pcb ) );
		pcb-&gt;is_internal = 1;
	}
	else
		pcb-&gt;is_internal = 0;

	/* Initialize Parser Control Block */
	pcb-&gt;stacksize = 0;
	if( @@prefix_alloc_stack( pcb ) &lt; 0 )
		return (@@goal-type)0;

	memset( pcb-&gt;tos, 0, sizeof( @@prefix_tok ) );

	pcb-&gt;act = UNICC_SHIFT;
	pcb-&gt;sym = -1;
	pcb-&gt;old_sym = -1;
	pcb-&gt;line = 1;
	pcb-&gt;column = 1;

	memset( &amp;pcb-&gt;test, 0, sizeof( @@prefix_vtype ) );

	/* Begin of main parser loop */
	while( 1 )
	{
		/* Reduce */
		while( pcb-&gt;act &amp; UNICC_REDUCE )
		{
#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: &lt;&lt; "
					"reducing by production %d (%s)\n",
						UNICC_PARSER, pcb-&gt;idx,
							@@prefix_productions[ pcb-&gt;idx ].definition );
#endif
			/* Set default left-hand side */
			pcb-&gt;lhs = @@prefix_productions[ pcb-&gt;idx ].lhs;

			/* Run reduction code */
			memset( &amp;( pcb-&gt;ret ), 0, sizeof( @@prefix_vtype ) );

			switch( pcb-&gt;idx )
			{
@@actions
			}

			/* Drop right-hand side */
			/* TODO: Destructor callbacks? */
			for( i = 0, node = (@@prefix_ast*)NULL;
					i &lt; @@prefix_productions[ pcb-&gt;idx ].length;
						i++ )
			{
				if( pcb-&gt;tos-&gt;node )
				{
					if( node )
					{
						while( node-&gt;prev )
							node = node-&gt;prev;

						node-&gt;prev = pcb-&gt;tos-&gt;node;
						pcb-&gt;tos-&gt;node-&gt;next = node;
					}

					node = pcb-&gt;tos-&gt;node;
					pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;
				}

				pcb-&gt;tos--;
			}

			/* This could be done if no AST construction would be done: */
			/* pcb-&gt;tos -= @@prefix_productions[ pcb-&gt;idx ].length; */

			if( node )
			{
				if( lnode = pcb-&gt;tos-&gt;node )
				{
					while( lnode-&gt;next )
						lnode = lnode-&gt;next;

					lnode-&gt;next = node;
					node-&gt;prev = lnode;
				}
				else
					pcb-&gt;tos-&gt;node = node;
			}

			if( *@@prefix_productions[ pcb-&gt;idx ].emit )
			{
				if( ( node = @@prefix_ast_create( pcb,
								@@prefix_productions[ pcb-&gt;idx ].emit,
									(UNICC_SCHAR*)NULL ) ) )
				{
					node-&gt;child = pcb-&gt;tos-&gt;node;
					pcb-&gt;tos-&gt;node = node;
				}
			}

			/* Enforced error in semantic actions? */
			if( pcb-&gt;act == UNICC_ERROR )
				break;

			/* Goal symbol reduced, and stack is empty? */
			if( pcb-&gt;lhs == @@goal &amp;&amp; pcb-&gt;tos == pcb-&gt;stack )
			{
				memcpy( &amp;( pcb-&gt;tos-&gt;value ), &amp;( pcb-&gt;ret ),
							sizeof( @@prefix_vtype ) );
				pcb-&gt;ast = pcb-&gt;tos-&gt;node;

				UNICC_CLEARIN( pcb );

				pcb-&gt;act = UNICC_SUCCESS;

				#if UNICC_DEBUG
				fprintf( stderr, "%s: goal symbol reduced, exiting parser\n",
						UNICC_PARSER );
				#endif
				break;
			}

			#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: after reduction, "
						"shifting nonterminal %d (%s)\n",
							UNICC_PARSER, pcb-&gt;lhs,
								@@prefix_symbols[ pcb-&gt;lhs ].name );
			#endif

			@@prefix_get_go( pcb );

			pcb-&gt;tos++;
			pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;

			memcpy( &amp;( pcb-&gt;tos-&gt;value ), &amp;( pcb-&gt;ret ),
						sizeof( @@prefix_vtype ) );
			pcb-&gt;tos-&gt;symbol = &amp;( @@prefix_symbols[ pcb-&gt;lhs ] );
			pcb-&gt;tos-&gt;state = ( pcb-&gt;act &amp; UNICC_REDUCE ) ? -1 : pcb-&gt;idx;
			pcb-&gt;tos-&gt;line = pcb-&gt;line;
			pcb-&gt;tos-&gt;column = pcb-&gt;column;
		}

		if( pcb-&gt;act == UNICC_SUCCESS || pcb-&gt;act == UNICC_ERROR )
			break;

		/* If in error recovery, replace old-symbol */
		if( pcb-&gt;error_delay == UNICC_ERROR_DELAY
				&amp;&amp; ( pcb-&gt;sym = pcb-&gt;old_sym ) &lt; 0 )
		{
			/* If symbol is invalid, try to find new token */
			#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: error recovery: "
				"old token invalid, requesting new token\n",
						UNICC_PARSER );
			#endif

			while( !@@prefix_get_sym( pcb ) )
			{
				/* Skip one character */
				pcb-&gt;len = 1;

				UNICC_CLEARIN( pcb );
			}

			#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: error recovery: "
				"new token %d (%s)\n", UNICC_PARSER, pcb-&gt;sym,
					@@prefix_symbols[ pcb-&gt;sym ].name );
			#endif
		}
		else
		{
			@@prefix_get_sym( pcb );
		}

#if UNICC_DEBUG
		fprintf( @@prefix_dbg, "%s: current token %d (%s)\n",
					UNICC_PARSER, pcb-&gt;sym,
						( pcb-&gt;sym &lt; 0 ) ? "(null)" :
							@@prefix_symbols[ pcb-&gt;sym ].name );
#endif

		/* Get action table entry */
		if( !@@prefix_get_act( pcb ) )
		{
			/* Error state, try to recover */
			if( @@prefix_handle_error( pcb,
#if UNICC_DEBUG
					@@prefix_dbg
#else
					(FILE*)NULL
#endif
					) )
				break;
		}

#if UNICC_DEBUG
		fprintf( @@prefix_dbg,
			"%s: sym = %d (%s) [len = %d] tos-&gt;state = %d act = %s idx = %d\n",
				UNICC_PARSER, pcb-&gt;sym,
					( ( pcb-&gt;sym &gt;= 0 ) ?
						@@prefix_symbols[ pcb-&gt;sym ].name :
							"(invalid symbol id)" ),
					pcb-&gt;len, pcb-&gt;tos-&gt;state,
						( ( pcb-&gt;act == UNICC_SHIFT &amp; UNICC_REDUCE ) ?
								"shift/reduce" :
							( pcb-&gt;act &amp; UNICC_SHIFT ) ?
									"shift" : "reduce" ), pcb-&gt;idx );
#if UNICC_STACKDEBUG
		@@prefix_dbg_stack( @@prefix_dbg, pcb-&gt;stack, pcb-&gt;tos );
#endif
#endif

		/* Shift */
		if( pcb-&gt;act &amp; UNICC_SHIFT )
		{
			pcb-&gt;next = pcb-&gt;buf[ pcb-&gt;len ];
			pcb-&gt;buf[ pcb-&gt;len ] = '\0';

#if UNICC_DEBUG
			fprintf( @@prefix_dbg, "%s: &gt;&gt; shifting terminal %d (%s)\n",
			UNICC_PARSER, pcb-&gt;sym, @@prefix_symbols[ pcb-&gt;sym ].name );
#endif

			if( @@prefix_alloc_stack( pcb ) &lt; 0 )
				return (@@goal-type)0;

			pcb-&gt;tos++;
			pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;

			/*
				Execute scanner actions, if existing.
				Here, UNICC_ON_SHIFT is set to 1, so that shifting-
				related operations will be performed.
			*/
#define UNICC_ON_SHIFT	1
			switch( pcb-&gt;sym )
			{
@@scan_actions

				default:
					@@top-value = @@prefix_get_input( pcb, 0 );
					break;
			}
#undef UNICC_ON_SHIFT

			pcb-&gt;tos-&gt;state = ( pcb-&gt;act &amp; UNICC_REDUCE ) ? -1 : pcb-&gt;idx;
			pcb-&gt;tos-&gt;symbol = &amp;( @@prefix_symbols[ pcb-&gt;sym ] );
			pcb-&gt;tos-&gt;line = pcb-&gt;line;
			pcb-&gt;tos-&gt;column = pcb-&gt;column;

			if( *pcb-&gt;tos-&gt;symbol-&gt;emit )
				pcb-&gt;tos-&gt;node = @@prefix_ast_create( pcb,
									pcb-&gt;tos-&gt;symbol-&gt;emit,
										@@prefix_lexem( pcb ) );
			else
				pcb-&gt;tos-&gt;node = (@@prefix_ast*)NULL;

			pcb-&gt;buf[ pcb-&gt;len ] = pcb-&gt;next;

			/* Perform the shift on input */
			if( pcb-&gt;sym != @@eof &amp;&amp; pcb-&gt;sym != @@error )
			{
				UNICC_CLEARIN( pcb );
				pcb-&gt;old_sym = -1;
			}

			if( pcb-&gt;error_delay )
				pcb-&gt;error_delay--;
		}
	}

	#if UNICC_DEBUG
	fprintf( @@prefix_dbg, "%s: parse completed with %d errors\n",
		UNICC_PARSER, pcb-&gt;error_count );
	#endif

	/* Save return value */
	ret = @@goal-value;

	/* Clean up parser control block */
	if( pcb-&gt;buf )
		free( pcb-&gt;buf );
	if( pcb-&gt;stack )
		free( pcb-&gt;stack );
#if UNICC_UTF8
	if( pcb-&gt;lexem )
		free( pcb-&gt;lexem );
#endif

	/* Clean memory of self-allocated parser control block */
	if( pcb-&gt;is_internal )
		free( pcb );

	return ret;
}

@@epilogue

/* Create Main? */
#if @@epilogue_len == 0
	#ifndef UNICC_MAIN
	#define UNICC_MAIN 	1
	#endif
#else
	#ifndef UNICC_MAIN
	#define UNICC_MAIN 	0
	#endif
#endif

#if UNICC_MAIN

int main( int argc, char** argv )
{
#define UNICCMAIN_SILENT		1
#define UNICCMAIN_ENDLESS		2
#define UNICCMAIN_LINEMODE		4
#define UNICCMAIN_SYNTAXTREE	8
#define UNICCMAIN_AUGSYNTAXTREE	16

	char*			opt;
	int				flags	= 0;
	int				i;
	@@prefix_pcb	pcb;

#ifdef LC_ALL
	setlocale( LC_ALL, "" );
#endif

	/* Get command-line options */
	for( i = 1; i &lt; argc; i++ )
	{
		if( *(argv[i]) == '-' )
		{
			opt = argv[i] + 1;

			/* Long option coming? */
			if( *opt == '-' )
			{
				opt++;

				if( !strcmp( opt, "silent" ) )
					flags |= UNICCMAIN_SILENT;
				else if( !strcmp( opt, "endless" ) )
					flags |= UNICCMAIN_ENDLESS;
				else if( !strcmp( opt, "line-mode" ) )
					flags |= UNICCMAIN_LINEMODE;
				else
				{
					fprintf( stderr, "Unknown option '--%s'\n", argv[i] );
					return 1;
				}
			}

			for( ; *opt; opt++ )
			{
				if( *opt == 's' )
					flags |= UNICCMAIN_SILENT;
				else if( *opt == 'e' )
					flags |= UNICCMAIN_ENDLESS;
				else if( *opt == 'l' )
					flags |= UNICCMAIN_LINEMODE;
				else
				{
					fprintf( stderr, "Unknown option '-%c'\n", *opt );
					return 1;
				}
			}
		}
	}

	/* Parser invocation loop */
	do
	{
		if( !( flags &amp; UNICCMAIN_SILENT ) )
			printf( "\nok\n" );

		/* Invoke parser */
		memset( &amp;pcb, 0, sizeof( @@prefix_pcb ) );

		if( flags &amp; UNICCMAIN_LINEMODE )
			pcb.eof = '\n';
		else
			pcb.eof = EOF;

		@@prefix_parse( &amp;pcb );

		/* Print AST */
		if( pcb.ast )
		{
			@@prefix_ast_print( stderr, pcb.ast );
			@@prefix_ast_free( pcb.ast );
		}
	}
	while( flags &amp; UNICCMAIN_ENDLESS );

	return 0;
}
#endif

</file>
<file filename="@@basename.h">/*
	Parser header generated by unicc from @@filename.
	DO NOT EDIT THIS FILE MANUALLY, IT WILL GO AWAY!
*/

#ifndef @@CBASENAME_H
#define @@CBASENAME_H

/* Wide character processing enabled? */
#ifndef UNICC_WCHAR
#define UNICC_WCHAR					0
#endif

/* UTF-8 processing enabled? */
#if !UNICC_WCHAR
#ifndef UNICC_UTF8
#	define UNICC_UTF8				1
#endif
#else
#	ifdef UNICC_UTF8
#	undef UNICC_UTF8
#	endif
#	define UNICC_UTF8				0
#endif

/* UNICC_CHAR is used as character type for internal processing */
#ifndef UNICC_CHAR
#if UNICC_UTF8 || UNICC_WCHAR
#	define UNICC_CHAR				wchar_t
#	define UNICC_CHAR_FORMAT		"%S"
#else
#	define UNICC_CHAR				char
#	define UNICC_CHAR_FORMAT		"%s"
#endif
#endif /* UNICC_CHAR */

/* UNICC_SCHAR defines the character type for semantic action procession */
#ifndef UNICC_SCHAR
#if UNICC_WCHAR
#	define UNICC_SCHAR				wchar_t
#	define UNICC_SCHAR_FORMAT		"%S"
#else
#	define UNICC_SCHAR				char
#	define UNICC_SCHAR_FORMAT		"%s"
#endif
#endif /* UNICC_SCHAR */

/* Boolean */
#ifndef UNICC_BOOLEAN
#define UNICC_BOOLEAN			short
#endif

/* Debug level */
#ifndef UNICC_DEBUG
#define UNICC_DEBUG				0
#endif

/* Stack debug switch */
#ifndef UNICC_STACKDEBUG
#define UNICC_STACKDEBUG		0
#endif

/* Parse error macro */
#ifndef UNICC_PARSE_ERROR
#define UNICC_PARSE_ERROR( pcb ) \
	fprintf( stderr, "line %d, column %d: syntax error on symbol %d, token '" \
		UNICC_SCHAR_FORMAT "'\n", \
	( pcb )-&gt;line, ( pcb )-&gt;column, pcb-&gt;sym, @@prefix_lexem( pcb ) )
#endif

/* Input buffering clean-up */
#ifndef UNICC_CLEARIN
#define UNICC_CLEARIN( pcb )		@@prefix_clear_input( pcb )
#endif

/*TODO:*/
#ifndef UNICC_NO_INPUT_BUFFER
#define UNICC_NO_INPUT_BUFFER	0
#endif

/* Memory allocation step size for dynamic stack- and buffer allocation */
#ifndef UNICC_MALLOCSTEP
#define UNICC_MALLOCSTEP		128
#endif

/* Call this when running out of memory during memory allocation */
#ifndef UNICC_OUTOFMEM
#define UNICC_OUTOFMEM( pcb )	fprintf( stderr, \
									"Fatal error, ran out of memory\n" ), \
								exit( 1 )
#endif

/* Static switch */
#ifndef UNICC_STATIC
#define UNICC_STATIC			static
#endif

#ifdef UNICC_PARSER
#undef UNICC_PARSER
#endif
#define UNICC_PARSER			"@@prefix" "debug"

/* Don't change next three defines below! */
#ifndef UNICC_ERROR
#define UNICC_ERROR				0
#endif
#ifndef UNICC_REDUCE
#define UNICC_REDUCE			1
#endif
#ifndef UNICC_SHIFT
#define UNICC_SHIFT				2
#endif
#ifndef UNICC_SUCCESS
#define UNICC_SUCCESS			4
#endif

/* Error delay after recovery */
#ifndef UNICC_ERROR_DELAY
#define UNICC_ERROR_DELAY		3
#endif

/* Enable/Disable terminal selection in semantic actions */
#ifndef UNICC_SEMANTIC_TERM_SEL
#define UNICC_SEMANTIC_TERM_SEL	0
#endif

/* Value Types */
@@value-type-definition

/* Typedef for symbol information table */
typedef struct
{
	char*			name;
	char*			emit;
	short			type;
	UNICC_BOOLEAN	lexem;
	UNICC_BOOLEAN	whitespace;
	UNICC_BOOLEAN	greedy;
} @@prefix_syminfo;

/* Typedef for production information table */
typedef struct
{
	char*	definition;
	char*	emit;
	int		length;
	int		lhs;
} @@prefix_prodinfo;


/* Abstract Syntax Tree */
typedef struct @@prefix_AST @@prefix_ast;

struct @@prefix_AST
{
	char*			emit;
	UNICC_SCHAR*	token;

	@@prefix_ast*	parent;
	@@prefix_ast*	child;
	@@prefix_ast*	prev;
	@@prefix_ast*	next;
};

/* Stack Token */
typedef struct
{
	@@prefix_vtype		value;
	@@prefix_ast*		node;

	@@prefix_syminfo*	symbol;

	int					state;
	unsigned int		line;
	unsigned int		column;
} @@prefix_tok;


/* Parser Control Block */
typedef struct
{
	/* Is this PCB allocated by parser? */
	char				is_internal;

	/* Stack */
	@@prefix_tok*		stack;
	@@prefix_tok*		tos;

	/* Stack size */
	unsigned int		stacksize;

	/* Values */
	@@prefix_vtype		ret;
	@@prefix_vtype		test;

	/* State */
	int					act;
	int					idx;
	int					lhs;

	/* Lookahead */
	int					sym;
	int					old_sym;
	unsigned int		len;

	/* Input buffering */
	UNICC_SCHAR*		lexem;
	UNICC_CHAR*			buf;
	UNICC_CHAR*			bufend;
	UNICC_CHAR*			bufsize;

	/* Lexical analysis */
	UNICC_CHAR			next;
	UNICC_CHAR			eof;
	UNICC_BOOLEAN		is_eof;

	/* Error handling */
	int					error_delay;
	int					error_count;

	unsigned int		line;
	unsigned int		column;

	/* Abstract Syntax Tree */
	@@prefix_ast*		ast;

	/* User-defined components */
	@@pcb

} @@prefix_pcb;

#endif /* @@CBASENAME_H */
</file>
</generator>
